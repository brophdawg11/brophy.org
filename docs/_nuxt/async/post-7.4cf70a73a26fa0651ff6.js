(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{241:function(n,e){n.exports={title:"The Power of Reduce",author:"Matt Brophy",postDate:"2019-01-28 21:30",tags:"javascript",__content:'<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">Array.prototype.reduce</a> method is one of those methods that is unnecessarily frightening at first glance.  It&#39;s something that I myself was uncomfortable with for much longer than needed early on in my career.  If you find yourself in that position, I hope this article helps change that.</p>\n<p>As I&#39;ve worked with <code>reduce</code> more and more, I am continually amazed that 10+ years into my professional Javascript career, I&#39;m still discovering new ways to use <code>reduce</code>.  Additionally, I&#39;m finding myself turning to it in situations where it wouldn&#39;t have occurred to me in the past.  </p>\n<p>According to <a href="https://www.merriam-webster.com/dictionary/reduce">Merriam-Webster</a>, &quot;reduce&quot; is defined as:</p>\n<blockquote>\n<p>to draw together or cause to converge</p>\n</blockquote>\n<p>I think this is a great starting point to explaining and understanding the Javascript <code>reduce</code> method.  It takes an Array (many values) and returns a single value.  This single value is generated by running a callback function on each entry of the array and &quot;accumulating&quot; each value of the array along the way into a stateful variable often referred to as the <code>accumulator</code>, or <code>acc</code>.</p>\n<p>Let&#39;s look at the function signature:</p>\n<pre><code class="hljs js">arr.reduce(callback[, initialValue])</code></pre>\n<p>This brings us to one of the first big gotcha&#39;s that I&#39;ve found over time, and an area where people often get tripped up.  I&#39;ll just put this out there now: <em>always, always, always use an initial value</em>.  At the very least, always use one until you&#39;ve really grasped <code>reduce</code>, and then maybe consider skipping it.  In my experience, that makes the cognitive overhead much less, and we&#39;ll only use that format in this post.  Maybe I&#39;ll write a follow up sometime on not using an <code>initialValue</code>, but honestly - I do it so infrequently, that it may not be worth a post.</p>\n<p>Now let&#39;s check out a very simple example.  Let&#39;s assume we want to add up an array of numbers:</p>\n<pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];</code></pre>\n<p>If we wanted to add these together manually, we might write something like:</p>\n<pre><code class="hljs js"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;\nsum += arr[<span class="hljs-number">0</span>];\nsum += arr[<span class="hljs-number">1</span>];\nsum += arr[<span class="hljs-number">2</span>];\nsum += arr[<span class="hljs-number">3</span>]; </code></pre>\n<p>Hmm, that doesn&#39;t really scale to arrays of differing lengths - it looks like we probably want to use a loop:</p>\n<pre><code class="hljs js"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {\n    sum += arr[i];\n}</code></pre>\n<p>That&#39;s much better.  Or is it?  If you&#39;ve been using a library like <a href="https://lodash.com/">lodash</a>, you may have began writing fewer and fewer <code>for</code> loops a while ago, but with the rise of ES6, chances are you&#39;re writing less of them now.  Almost to the point that they might start to feel like <em>&quot;code smell.&quot;</em>  Why write a <code>for</code> loop when we can avoid those off-by-one errors using <code>forEach</code>?  Let&#39;s take a look at the altered version of this using <code>forEach</code>:</p>\n<pre><code class="hljs js"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;\narr.forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> sum += v);</code></pre>\n<p>Neat!  Even smaller, no iteration variables to worry about.  This is where I stopped for a long time.  But that&#39;s only because I wasn&#39;t seeing <em>&quot;the pattern.&quot;</em>  </p>\n<p>Recall our definition earlier of reducing many values to a single value, and then look more closely at this <code>forEach</code> loop.  We start with many values (<code>arr</code>) and we end with a single value (<code>sum</code>).  So we&#39;re in a prime spot to use <code>reduce</code>.  Let&#39;s see what that would look like:</p>\n<pre><code class="hljs js"><span class="hljs-keyword">const</span> sum = arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, v</span>) =&gt;</span> acc + v, <span class="hljs-number">0</span>);</code></pre>\n<p>As an added benefit, we also get rid of the closure-scoped <code>sum</code> variable access!  But what exactly is happening here?  Let&#39;s break it down.  </p>\n<p>First off, the <code>callback()</code> function that you supply to <code>reduce</code> accepts 4 parameters, but in our current case, only the first 2 are relevant: </p>\n<pre><code class="hljs js">callback(accumulator, currentValue)</code></pre>\n<p>The <code>currentValue</code> is the current value of the array being iterated over - the same argument you&#39;d get in a <code>forEach</code> loop.  And in this case, the <code>accumulator</code> is the ever-growing <code>sum</code> variable from our <code>forEach</code> example.  </p>\n<p>Secondly, we&#39;re using an <code>initialValue</code> of 0 - which is what we&#39;ll initialize our accumulator with.  Let&#39;s see how this looks step by step if we unroll it:</p>\n<pre><code class="hljs js"><span class="hljs-comment">// Define our callback function</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">accumulator, currentValue</span>) </span>{\n    <span class="hljs-keyword">return</span> accumulator + currentValue;\n}\n\n<span class="hljs-comment">// Initialization: accumulator = initialValue</span>\naccumulator0 = <span class="hljs-number">0</span>;\n\n<span class="hljs-comment">// Iteration 0</span>\naccumulator1 = add(accumulator0, arr[<span class="hljs-number">0</span>]);\n\n<span class="hljs-comment">// Iteration 1</span>\naccumulator2 = add(accumulator1, arr[<span class="hljs-number">1</span>]);\n\n<span class="hljs-comment">// Iteration 2</span>\naccumulator3 = add(accumulator2, arr[<span class="hljs-number">2</span>]);\n\n<span class="hljs-comment">// Iteration 3</span>\naccumulator4 = add(accumulator3, arr[<span class="hljs-number">3</span>]);</code></pre>\n<p>See how the reduce is just a series of calling the same function over and over, passing the result of the prior execution in as the accumulator of the next execution?  That&#39;s how we&#39;re doing the accumulation - modifying the accumulator in each step, and passing it to the next step.  To me, <code>reduce</code> is all about remembering to:</p>\n<ul>\n<li>Always provide an initial value</li>\n<li>Always return an <code>accumulator</code>, modified if needed</li>\n</ul>\n<p>What if we wanted to only act on <em>some</em> of our array values?  That&#39;s easy, we can no-op in a reducer function by just returning the input <code>accumulator</code>.  Let&#39;s take a look at adding only the even numbers in an array:</p>\n<pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];\n<span class="hljs-keyword">const</span> evenSum = arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, v</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span> (v % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {\n        <span class="hljs-comment">// Number is eve, add it</span>\n        <span class="hljs-keyword">return</span> acc + v;\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-comment">// Number is odd, skip it</span>\n        <span class="hljs-keyword">return</span> acc;\n    }\n}, <span class="hljs-number">0</span>);  <span class="hljs-comment">// &lt;-- Don\'t forget the initialValue!</span>\n\n<span class="hljs-comment">// And in a more terse manner:</span>\n<span class="hljs-keyword">const</span> evenSum = arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, v</span>) =&gt;</span> (v % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) ? acc + v : acc, <span class="hljs-number">0</span>);</code></pre>\n<h2 id="advanced-usage">Advanced Usage</h2>\n<p>Now that we&#39;ve seen the basics of reduce, let&#39;s take a look at some of the more advanced use-cases I&#39;ve found useful in the past.  For each example, I&#39;ll show a more verbose, but more explicit method, as well as one or more less-verbose methods.  There&#39;s no right or wrong way to use these, it will all depend on personal and team preference, and comfortability with the reduce method, and other ES6 functionality.</p>\n<h3 id="indexing-an-array-of-items-by-a-key">Indexing an array of items by a key</h3>\n<pre><code class="hljs js"><span class="hljs-keyword">const</span> items = [\n    { <span class="hljs-attr">userId</span>: <span class="hljs-string">\'1\'</span>, <span class="hljs-attr">firstName</span>: <span class="hljs-string">\'Matt\'</span> },\n    { <span class="hljs-attr">userId</span>: <span class="hljs-string">\'2\'</span>, <span class="hljs-attr">firstName</span>: <span class="hljs-string">\'Jane\'</span> },\n    { <span class="hljs-attr">userId</span>: <span class="hljs-string">\'3\'</span>, <span class="hljs-attr">firstName</span>: <span class="hljs-string">\'Bob\'</span> }\n];\n\n<span class="hljs-comment">// Reduce into an empty object, adding each user in a key/value pair</span>\n<span class="hljs-keyword">const</span> userMap = items.reduce(<span class="hljs-function">(<span class="hljs-params">acc, item</span>) =&gt;</span> {\n    acc[item.userId] = item;\n    <span class="hljs-keyword">return</span> acc;\n}, {});\n\n<span class="hljs-comment">// Less-verbose approach:</span>\n<span class="hljs-keyword">const</span> userMap = items.reduce(<span class="hljs-function">(<span class="hljs-params">acc, item</span>) =&gt;</span> <span class="hljs-built_in">Object</span>.assign(acc, {\n    [item.userId]: item,\n}), {});\n\n<span class="hljs-comment">// userMap:</span>\n<span class="hljs-comment">// {</span>\n<span class="hljs-comment">//   \'1\': { id: \'1\', firstName: \'Matt\' }</span>\n<span class="hljs-comment">//   \'2\': { id: \'2\', firstName: \'Jane\' }</span>\n<span class="hljs-comment">//   \'3\': { id: \'3\', firstName: \'Bob\' }</span>\n<span class="hljs-comment">// }</span>\n</code></pre>\n<h3 id="groupingchunking-arrays">Grouping/Chunking Arrays</h3>\n<p>Let&#39;s say we want to look through an array of items, and group them by some shared characteristic.</p>\n<pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];\n\n<span class="hljs-comment">// Reduce into an object that will have an "even" array and an "odd" array</span>\n<span class="hljs-keyword">const</span> evensAndOdds = arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, v</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span> (v % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {\n        acc.even.push(v);\n    } <span class="hljs-keyword">else</span>  {\n        acc.odd.push(v);\n    }\n    <span class="hljs-keyword">return</span> acc;\n}, { <span class="hljs-attr">even</span>: [], <span class="hljs-attr">odd</span>: [] });\n\n<span class="hljs-comment">// Slightly less verbose?</span>\n<span class="hljs-keyword">const</span> evensAndOdds = arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, v</span>) =&gt;</span> (v % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) ? {\n    <span class="hljs-attr">even</span>: acc.even.concat([v]),\n    <span class="hljs-attr">odd</span>: acc.odd,\n} : {\n    <span class="hljs-attr">even</span>: acc.even,\n    <span class="hljs-attr">odd</span>: acc.odd.concat([v]),\n}, { <span class="hljs-attr">even</span>: [], <span class="hljs-attr">odd</span>: [] });\n\n<span class="hljs-comment">// Less verbose, no initial structure</span>\n<span class="hljs-keyword">const</span> evensAndOdds = arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, v</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> key = (v % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) ? <span class="hljs-string">\'even\'</span> : <span class="hljs-string">\'odd\'</span>;\n    acc[key] = (acc[key] || []).concat([v]);\n    <span class="hljs-keyword">return</span> acc;\n}, {});\n\n<span class="hljs-comment">// evensAndOdds:</span>\n<span class="hljs-comment">// {</span>\n<span class="hljs-comment">//     even: [2, 4, 6],</span>\n<span class="hljs-comment">//     odd: [1, 3, 5],</span>\n<span class="hljs-comment">// }</span></code></pre>\n<h3 id="mapping-object-values">Mapping Object Values</h3>\n<pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = {\n    <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,\n    <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span>,\n    <span class="hljs-attr">baz</span>: <span class="hljs-number">3</span>\n};\n\n<span class="hljs-keyword">const</span> valuesSquared = <span class="hljs-built_in">Object</span>.keys(obj).reduce(\n    <span class="hljs-function">(<span class="hljs-params">acc, k</span>) =&gt;</span> <span class="hljs-built_in">Object</span>.assign(acc, { [k]: obj[k] * obj[k] }),\n    {}\n);\n\n<span class="hljs-comment">// Using Object.entries and array destructuring</span>\n<span class="hljs-keyword">const</span> valuesSquared = <span class="hljs-built_in">Object</span>.entries(obj).reduce(\n    <span class="hljs-function">(<span class="hljs-params">acc, [k, v]</span>) =&gt;</span> <span class="hljs-built_in">Object</span>.assign(acc, { [k]: v * v, }),\n    {}\n);\n\n<span class="hljs-comment">// valuesSquared:</span>\n<span class="hljs-comment">// {</span>\n<span class="hljs-comment">//     foo: 1,</span>\n<span class="hljs-comment">//     bar: 4,</span>\n<span class="hljs-comment">//     baz: 9</span>\n<span class="hljs-comment">// }</span></code></pre>\n<h3 id="sequential-asynchronous-promise-chains">Sequential Asynchronous Promise Chains</h3>\n<p>Ever find yourself needing to perform a series of sequential, but asynchronous actions based on an input array of data?  We can reduce that array onto a single promise chain!</p>\n<pre><code class="hljs js"><span class="hljs-comment">// Dummy async function that we want to run for a handful of IDs</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomethingAsyncForId</span>(<span class="hljs-params">id</span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="hljs-number">1000</span>));\n}\n\n<span class="hljs-keyword">const</span> ids = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];\nids.reduce(\n    <span class="hljs-function">(<span class="hljs-params">acc, id</span>) =&gt;</span> acc.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> doSomethingAsyncForId(id)), \n    <span class="hljs-built_in">Promise</span>.resolve()\n);</code></pre>\n<p>As you can see - there are lots of use cases for reduce, but they all follow that same pattern of turning many values into one value.</p>\n<p>Happy Reducing!</p>\n<p>For additional reading, Sarah Drasner also has a great article on reducers over on CSS Tricks - <a href="https://css-tricks.com/understanding-the-almighty-reducer/">Understanding the Almighty Reducer</a>.</p>\n',excerpt:'The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">Array.prototype.reduce</a> method is one of those methods that is unnecessarily frightening at first glance.  It&apos;s something that I myself was uncomfortable with for much longer than needed early on in my career.  If you find yourself in that position, I hope this article helps change that.',permalink:"/post/the-power-of-reduce",readingTime:{text:"9 min read",minutes:8.33,time:499800,words:1666},slug:"the-power-of-reduce"}}}]);
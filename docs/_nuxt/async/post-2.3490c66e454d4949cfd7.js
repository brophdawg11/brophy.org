(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{259:function(e,n){e.exports={title:"Beware of hidden inputs in Angular filters",author:"Matt Brophy",postDate:"2017-01-14 12:00",tags:"angularjs,javascript,functional",__content:'<p>If you&#39;ve been writing JavaScript (or really any language for that matter) in the past few years, chances are you&#39;ve caught wind of the rising popularity of functional programming paradigms.  <em>Pure functions</em> are one of the major concepts of functional programming, and as it turns out, the usage of impure functions in Angular filters can produce some not-so-obvious bugs in your AngularJS application.</p>\n<p>Don&#39;t worry, I&#39;m not going to get into a big discussion of the advantages of functional programing/pure functions/immutability in this post.  There&#39;s plenty of stuff out there from people far smarter than me that you can find with a few simple Google searches.  However, this Angular filter nuance almost bit me recently, and the subtle nature of it caught me by surprise - even though it seems pretty blatantly obvious after the fact.  </p>\n<p><strong>TL;DR;</strong> Here&#39;s a quick <a href="https://plnkr.co/edit/WMMNWiSqE0Uij9ZXwy4G?p=preview" title="Broken Filter Example">Plnkr</a> demonstrating a broken and fixed filter using impure/pure functions in Angular.</p>\n<h3 id="pure-functions">Pure Functions</h3>\n<p>For some quick reading on pure functions, I would recommend reading Kris Jenkins&#39; great <a href="http://blog.jenkster.com/2015/12/what-is-functional-programming.html" title="What is Functional Programming">What is Functional Programming</a> article or checking out the Wikipedia page for <a href="https://en.wikipedia.org/wiki/Pure_function" title="Pure Function">Pure Functions</a>.  In short, a pure function should have explicit inputs, zero side-effects, and always produce the same output for a set of inputs.</p>\n<pre><code class="hljs javascript"><span class="hljs-comment">// Bad: Impure function - hidden input from SalesService</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateTaxBad</span>(<span class="hljs-params">price</span>) </span>{\n    <span class="hljs-keyword">return</span> price * SalesService.getTaxRate());\n}\n\n<span class="hljs-comment">// Good: Pure function - no hidden inputs</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateTaxGood</span>(<span class="hljs-params">price, taxRate</span>) </span>{\n    <span class="hljs-keyword">return</span> price * taxRate;\n}</code></pre>\n<p>In the second example, we&#39;ve removed the hidden <code>SalesService.getTaxRate()</code> input and made it an explicit input to the function.</p>\n<h3 id="angular-filters">Angular Filters</h3>\n<p><a href="https://code.angularjs.org/1.4.14/docs/guide/filter" title="Angular Filters">Angular filters</a> are a handy little mechanism for transforming data within Angular templates.</p>\n<pre><code class="hljs javascript">angular.module(<span class="hljs-string">\'app\'</span>).filter(<span class="hljs-string">\'uppercase\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">input</span>) </span>{\n    <span class="hljs-keyword">return</span> (input || <span class="hljs-string">\'\'</span>).toUpperCase();\n  };\n})</code></pre>\n<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{ \'hello world\' | uppercase }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n\n<span class="hljs-comment">&lt;!-- produces --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>HELLO WORLD<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre>\n<p>Cool - super simple, super useful.</p>\n<h3 id="impure-functions-as-angular-filters">Impure functions as Angular filters</h3>\n<p>So what&#39;s the problem?  It comes down to to the logic used in the dirty checking in Angular&#39;s digest cycles.  Let&#39;s pretend we wanted to use our <code>calculateTaxBad</code> method above as a filter to produce an itemized pricing display:</p>\n<pre><code class="hljs javascript">angular.module(<span class="hljs-string">\'app\'</span>).filter(<span class="hljs-string">\'taxBroken\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">SalesService</span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">price</span>) </span>{\n        <span class="hljs-keyword">return</span> price * SalesService.getTaxRate();\n    }    \n});</code></pre>\n<p>We could then generate the display:</p>\n<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Price: {{ item.price | currency }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Tax: {{ item.price | taxBroken | currency }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>\n<p>This is where the &quot;magical&quot; nature of Angular&#39;s digest cycle almost came back to bite me.  At first glance, it seems reasonable to think that when the digest cycle runs, it&#39;ll evaluate the <em>entire</em> expression <code>{{ item.price | taxBroken | currency }}</code> and determine if a re-render is required.  </p>\n<p>However, if we look deep into the internals of Angular&#39;s parser and dirty checking logic, we can see where the problem arises:</p>\n<p><a href="/assets/images/post/beware-hidden-inputs-in-angular-filters/parser-filter-impure.png"><img src="/assets/images/post/beware-hidden-inputs-in-angular-filters/parser-filter-impure.png" alt="Filter with hidden input"></a></p>\n<p>When parsing the expression, Angular determines that there is only one input for the expression, <code>data.price</code>.  This is based on an internal Angular assumption that the filter is pure, and therefore given one input, it will always produce the same output.  Thus, Angular doesn&#39;t need to bother executing the <code>taxBroken</code> or <code>currency</code> filters if <code>data.price</code> hasn&#39;t changed, because by definition, the output will not change.  And boom - the nasty hidden input gets ignored and our UI is broken if the <code>SalesService.taxRate</code> value changes without the corresponding price changing.</p>\n<h3 id="pure-functions-as-angular-filters">Pure functions as Angular filters</h3>\n<p>the fix is fairly straightforward now that we know what the problem is.  By removing the hidden input, we can adjust our filter:</p>\n<pre><code class="hljs javascript">angular.module(<span class="hljs-string">\'app\'</span>).filter(<span class="hljs-string">\'taxFixed\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">SalesService</span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">price, taxRate</span>) </span>{\n        <span class="hljs-keyword">return</span> price * taxRate;\n    }    \n});</code></pre>\n<p>We could then generate the display by explicitly passing the taxRate as a second input to the filter:</p>\n<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Price: {{ item.price | currency }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Tax: {{ item.price | taxFixed:getTaxRate() | currency }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>\n<p>Now, let&#39;s look again at the Angular internals:</p>\n<p><a href="/assets/images/post/beware-hidden-inputs-in-angular-filters/parser-filter-pure.png"><img src="/assets/images/post/beware-hidden-inputs-in-angular-filters/parser-filter-pure.png" alt="Filter with hidden input"></a></p>\n<p>We can see by adjusting the filter to pass the <code>taxRate</code> in as an input to the filter, the expression is now parsed with 2 inputs, the same first input as before, and an additional second input which is a function call corresponding to <code>getTaxRate()</code>.  </p>\n<p>This produces our Plnkr UI showing the live usages of the broken and fixed versions of the filter while updating the tax rate:</p>\n<p><img src="/assets/images/post/beware-hidden-inputs-in-angular-filters/output.png" alt="Plnkr UI"></p>\n<h3 id="takeaway">Takeaway</h3>\n<p>In Angular&#39;s defense, they are actually quite <a href="https://code.angularjs.org/1.4.14/docs/guide/filter#creating-custom-filters" title="Angular Custom Filters">explicit</a> about this in their documentation, but it&#39;s buried a bit down in the <code>$filter</code> documentation.  And, to be honest, I would venture to guess that most beginners learning how to implement filters are not reading the full Angular docs, but rather reading from a simplified blog post or Stack Overflow response that may not touch on the pure function requirement</p>\n<blockquote>\n<p> The filter function should be a <a href="https://en.wikipedia.org/wiki/Pure_function" title="Pure Function">pure function</a>, which means that it should be stateless and idempotent. Angular relies on these properties and executes the filter only when the inputs to the function change.</p>\n</blockquote>\n<p>That&#39;s it for today.  Hopefully this helps someone, somewhere, trying to track down a filter bug in their app.</p>\n',excerpt:"If you&apos;ve been writing JavaScript (or really any language for that matter) in the past few years, chances are you&apos;ve caught wind of the rising popularity of functional programming paradigms.  <em>Pure functions</em> are one of the major concepts of functional programming, and as it turns out, the usage of impure functions in Angular filters can produce some not-so-obvious bugs in your AngularJS application.",permalink:"/post/beware-hidden-inputs-in-angular-filters",readingTime:{text:"5 min read",minutes:4.725,time:283500,words:945},slug:"beware-hidden-inputs-in-angular-filters"}}}]);
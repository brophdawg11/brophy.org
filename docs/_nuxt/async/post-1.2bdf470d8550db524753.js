(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{235:function(n,e){n.exports={title:"Component-Driven Performance Patterns in Vue",author:"Matt Brophy",postDate:"2019-02-28 20:00",tags:"vue,javascript,spa,performance",draft:!0,__content:'<p>As web apps grow more complex, we end up sending larger JS/CSS bundles to the client.  If you&#39;re not careful, before long you can find yourself with a site that no longer snappy on slower connections due to the sheer amount of time it takes to send the bundles across the wire.  This post aims to document  handful of patterns we&#39;ve found handy at <a href="www.urbn.com">URBN</a> to keep bundles small and our load times fast.</p>\n<h2 id="what-is-performance">What is &quot;Performance&quot;?</h2>\n<p><em>Performance</em> is an overly vague term often tossed around without proper specificity or context.  Performance can be impacted by any number of the following concepts, as well as any number of additional things not mentioned here:</p>\n<ul>\n<li>Server response time</li>\n<li>Initial HTML payload size</li>\n<li>Number of HTTP requests</li>\n<li>Asset size/compression</li>\n<li>Image formats and optimizations</li>\n<li>CSS Selector complexity</li>\n<li>Caching</li>\n<li>Bandwidth</li>\n<li>CPU speed</li>\n<li>etc.</li>\n</ul>\n<p>To further complicate matters, we can measure performance using any number of metrics and methods:</p>\n<ul>\n<li>Time to First Paint (TTFP)</li>\n<li>SpeedIndex</li>\n<li>Time to Interactive</li>\n<li>DOM Ready</li>\n<li>Page Load</li>\n<li>Synthetic/Real-User (RUM)</li>\n<li>etc.</li>\n</ul>\n<p>Thus, I&#39;ve always found that any meaningful discussion around performance needs to properly define the aspects of performance that are being discussed, measured, and hopefully improved.</p>\n<p>In this post, we will focus on minimizing the amount of JS we send to the client on initial render - thus hopefully speeding up our TTI metrics for the user.</p>\n<h2 id="performance-budgets">Performance Budgets</h2>\n<p>While I&#39;m unsure who coined the <em>Performance Budget</em> term, I came across the following article by Alex Russell at Google a while back, and it has largely been the basis for a lot of the performance work we&#39;ve been doing at <a href="www.urbn.com">URBN</a> over the past year or so.</p>\n<blockquote>\n<p><a href="https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/">Can You Afford It?: Real-world Web Performance Budgets</a></p>\n</blockquote>\n<p>In a nutshell, using data such as network transfer speeds and CPU processing power, Alex calculates that if you want to achieve a sub-5 second TTI for users on an average mobile device on a 3G connection, you can afford to send <strong>~130Kb of gzipped Javascript</strong> to the client.  At a first glance, you may think this sounds like a fair amount.  That&#39;s close to 1MB uncompressed (but still minified).  However, the use of popular libraries can very quickly eat into most or all of that budget if you&#39;re not careful.  Take a look at the sizes of some of the popular libraries:</p>\n<ul>\n<li><a href="https://jquery.com/">jQuery</a>: 26Kb gzipped</li>\n<li><a href="https://lodash.com/">Lodash</a>: 20Kb gzipped</li>\n<li><a href="https://momentjs.com/">Moment</a>: 15Kb gzipped</li>\n<li><a href="https://vuejs.org/">Vue</a>/<a href="https://vuex.vuejs.org/">Vuex</a>/<a href="https://router.vuejs.org/">Vue-Router</a>: 30Kb</li>\n</ul>\n<p>As you can see, it&#39;s really easy to eat into that 130Kb, with these libraries alone we&#39;ve used up 91Kb, or 70% of our budget - and we haven&#39;t written a single line of our own app code.</p>\n<h3 id="quick-wins">Quick wins</h3>\n<p>Since library-choices aren&#39;t specifically what we want to focus on in this post, I&#39;ll just say there are a few quick wins you can and should evaluate.  </p>\n<ul>\n<li>Consider each third party library you choose to bring into your codebase, and it&#39;s impact on your budget</li>\n<li>Use vanilla JS where you can</li>\n<li>Choose smaller alternatives where possible (<a href="https://github.com/date-fns/date-fns">date-fns</a> over Moment)</li>\n<li>Use techniques such as <a href="https://webpack.js.org/guides/tree-shaking/">Tree Shaking</a> to remove unused code<ul>\n<li>Look for tree-shakable libraries where possible(<a href="https://www.npmjs.com/package/lodash-es">lodash-es</a> over the standard build) </li>\n</ul>\n</li>\n<li>Use webpack&#39;s <a href="https://webpack.js.org/configuration/performance/#performancemaxentrypointsize">Performance Configurations</a> to alert you when your bundle grow beyond the acceptable limit</li>\n</ul>\n<h2 id="dynamic-imports-and-async-components">Dynamic Imports and Async Components</h2>\n<p>Which brings us to the main concept of this post - using webpack <a href="https://webpack.js.org/guides/code-splitting/#dynamic-imports">Dynamic Imports</a> to load code asynchronously only when it&#39;s needed.  Thankfully, if you&#39;re using Vue, this gets even easier with the use of <a href="https://vuejs.org/v2/guide/components-dynamic-async.html#Async-Components">Async Components</a>.</p>\n<p>An Async Component in Vue is a component that instead of being bundled directly into your main app bundles, is instead split into it&#39;s own file (via dynamic imports) and only loaded when you render it into the UI.</p>\n<h3 id="basic-async-component">Basic Async Component</h3>\n<p>Consider the following example:</p>\n<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"toggleDetails"</span>&gt;</span>Show Details<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">DetailsComponent</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"showDetails"</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n<span class="hljs-comment">// Bad!  Bundled into the critical path even though it\'s not shown</span>\n<span class="hljs-keyword">import</span> DetailsComponent <span class="hljs-keyword">from</span> <span class="hljs-string">\'./DetailsComponent.vue\'</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    <span class="hljs-attr">components</span>: {\n        DetailsComponent,\n    },\n    data() {\n        <span class="hljs-keyword">return</span> {\n            <span class="hljs-attr">showDetails</span>: <span class="hljs-literal">false</span>,\n        };\n    },\n    <span class="hljs-attr">methods</span>: {\n        toggleDetails() {\n            <span class="hljs-keyword">this</span>.showDetails = !<span class="hljs-keyword">this</span>.showDetails;\n        },\n    },\n};</span></code></pre><p>We&#39;ve got a <code>DetailsComponent</code> that is always hidden on initial render and only shown when the user clicks a button.  There&#39;s no need to send this component up in the initial render, so we can use a dynamic import to split it out into it&#39;s own file by changing two lines of code:</p>\n<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"toggleDetails"</span>&gt;</span>Show Details<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">DetailsComponent</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"showDetails"</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    <span class="hljs-attr">components</span>: {\n        <span class="hljs-comment">// Good!  Loaded on-demand when it\'s shown</span>\n        DetailsComponent: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">\'./DetailsComponent.vue\'</span>),\n    },\n    data() {\n        <span class="hljs-keyword">return</span> {\n            <span class="hljs-attr">showDetails</span>: <span class="hljs-literal">false</span>,\n        };\n    },\n    <span class="hljs-attr">methods</span>: {\n        toggleDetails() {\n            <span class="hljs-keyword">this</span>.showDetails = !<span class="hljs-keyword">this</span>.showDetails;\n        },\n    },\n};</span></code></pre><p>Now, webpack will split all of the code for <code>DetailsComponent.vue</code>, and all of it&#39;s dependencies, into their own separate JS file, which Vue will not load until the user clicks the button.  this is a very powerful pattern that can be leveraged in a variety of ways to reduce our critical bundle sizes and improve app performance.</p>\n<h3 id="route-level-async-components">Route-level Async Components</h3>\n<p>Most applications consist of a number of separate routes, loading a root component per-route.  Using static imports, we bundle all of our route components into the same critical-path bundle:</p>\n<pre><code class="hljs js"><span class="hljs-comment">// Bad!  All routes bundled together into the critical path</span>\n<span class="hljs-keyword">import</span> HomepageView <span class="hljs-keyword">from</span> <span class="hljs-string">\'./HomepageView.vue\'</span>;\n<span class="hljs-keyword">import</span> AboutView <span class="hljs-keyword">from</span> <span class="hljs-string">\'./AboutView.vue\'</span>;\n\n<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter({\n    <span class="hljs-attr">routes</span>: [{\n        <span class="hljs-attr">path</span>: <span class="hljs-string">\'/\'</span>,\n        <span class="hljs-attr">component</span>: HomepageView\n    }, {\n        <span class="hljs-attr">path</span>: <span class="hljs-string">\'/about\'</span>,\n        <span class="hljs-attr">component</span>: AboutView,\n    }],\n};</code></pre>\n<p>We can use async components in our route definitions to only load each route component when we route to that page:</p>\n<pre><code class="hljs js"><span class="hljs-comment">// Good!  Each route loaded only when routed to</span>\n<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter({\n    <span class="hljs-attr">routes</span>: [{\n        <span class="hljs-attr">path</span>: <span class="hljs-string">\'/\'</span>,\n        <span class="hljs-attr">component</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">\'./HomepageView.vue\'</span>),\n    }, {\n        <span class="hljs-attr">path</span>: <span class="hljs-string">\'/about\'</span>,\n        <span class="hljs-attr">component</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">\'./AboutView.vue\'</span>),\n    }],\n};</code></pre>\n<h3 id="dynamic-vuex-modules">Dynamic Vuex Modules</h3>\n<p>In larger-scale apps, we&#39;ll have a Vuex store to help with state management, and we may portion off our store into sections relevant to routes in our app:</p>\n<pre><code class="hljs js"><span class="hljs-comment">// Bad!  All routes included in the root store in the critical path</span>\n<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store({\n    <span class="hljs-attr">state</span>: {\n        <span class="hljs-attr">homepage</span>: {\n            <span class="hljs-attr">data</span>: { ... },\n        },\n        <span class="hljs-attr">about</span>: {\n            <span class="hljs-attr">data</span>: { ... }\n        },\n    },\n    <span class="hljs-attr">mutations</span>: {\n        SET_HOMEPAGE_DATA(state, data) {\n            state.homepage.data = data\n        },\n        SET_ABOUT_DATA(state, data) {\n            state.about.data = data\n        },\n    },\n    <span class="hljs-attr">actions</span>: {\n        LOAD_HOMEPAGE_DATA({ commit }) {\n            axios.get(<span class="hljs-string">\'/api/homepage/data\'</span>)\n                .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> commit(SET_HOMEPAGE_DATA, data));\n        },\n        LOAD_ABOUT_DATA({ commit }) {\n            axios.get(<span class="hljs-string">\'/api/about/data\'</span>)\n                .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> commit(SET_ABOUT_DATA, data));\n        },\n    },\n};</code></pre>\n<p>Over time, this can lead to a very large store, with blurred boundaries about which state/mutations/actions are used by which routes.  A better approach would be to use <a href="https://vuex.vuejs.org/guide/modules.html">Vuex Modules</a> to keep each our routes stores separate:</p>\n<pre><code class="hljs js"><span class="hljs-comment">// Better - routes are separated into modules...but still loaded on </span>\n<span class="hljs-comment">// the critical path</span>\n<span class="hljs-keyword">const</span> homepageModule = {\n    <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,\n    <span class="hljs-attr">state</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({\n        <span class="hljs-attr">data</span>: { ... },\n    }),\n    <span class="hljs-attr">mutations</span>: {\n        SET_HOMEPAGE_DATA(state, data) {\n            state.data = data\n        },\n    },\n    <span class="hljs-attr">actions</span>: {\n        LOAD_HOMEPAGE_DATA({ commit }) {\n            axios.get(<span class="hljs-string">\'/api/homepage/data\'</span>)\n                .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> commit(SET_HOMEPAGE_DATA, data));\n        },\n    },\n};\n\n<span class="hljs-keyword">const</span> aboutModule = {\n    <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,\n    <span class="hljs-attr">state</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({\n        <span class="hljs-attr">data</span>: { ... },\n    }),\n    <span class="hljs-attr">mutations</span>: {\n        SET_ABOUT_DATA(state, data) {\n            state.data = data\n        },\n    },\n    <span class="hljs-attr">actions</span>: {\n        LOAD_ABOUT_DATA({ commit }) {\n            axios.get(<span class="hljs-string">\'/api/about/data\'</span>)\n                .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> commit(<span class="hljs-string">\'SET_ABOUT_DATA\'</span>, data));\n        },\n    },\n};\n\n<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store({\n    <span class="hljs-attr">state</span>: {},\n    <span class="hljs-attr">modules</span>: {\n        <span class="hljs-attr">homepage</span>: homepageModule,\n        <span class="hljs-attr">about</span>: aboutModule,\n    },\n};</code></pre>\n<p>This approach will scale much better as our app grows - however, we&#39;re still statically including each module in the critical path bundle.  If a user goes to the homepage - ideally we would only load the homepage module - and delay loading the about module until they click through to the about page.</p>\n<p>To accomplish this, we can move the modules into the components and thus bundle them with the component dynamic imports.</p>\n<pre><code>// Homepage.vue\n<span class="hljs-variable">&lt;script&gt;</span>\nconst homepageModule = {\n    namespaced: true,\n    <span class="hljs-keyword">state</span>: () =&gt; ({\n        data: { ... },\n    }),\n    mutations: {\n        SET_HOMEPAGE_DATA(<span class="hljs-keyword">state</span>, data) {\n            <span class="hljs-keyword">state</span>.data = data\n        },\n    },\n    actions: {\n        LOAD_HOMEPAGE_DATA({ commit }) {\n            axios.get(\'/api/homepage/data\')\n                .then(data =&gt; commit(SET_HOMEPAGE_DATA, data));\n        },\n    },\n};\n</code></pre><ul>\n<li>Route level</li>\n<li>Lazy vuex modules</li>\n<li>Moving Vuex modules into components</li>\n<li>On click</li>\n<li>Loading states/Error states</li>\n<li>Below the fold (IntersectionObserver)</li>\n<li>Changing behavior of components (lazy load images)</li>\n<li>Loading portions of a component (icons)</li>\n<li>Conclusion<ul>\n<li>Only deliver what is above-the-fold/user-visible/SEO critical on first load</li>\n<li>Lazy load everything else base don user actions (click, scroll)</li>\n<li>Push all dependencies behind the component entry point (vuex, third party libs, etc.)</li>\n<li>Lazy load images, icons, etc.</li>\n</ul>\n</li>\n</ul>\n',excerpt:'As web apps grow more complex, we end up sending larger JS/CSS bundles to the client.  If you&apos;re not careful, before long you can find yourself with a site that no longer snappy on slower connections due to the sheer amount of time it takes to send the bundles across the wire.  This post aims to document  handful of patterns we&apos;ve found handy at <a href="www.urbn.com">URBN</a> to keep bundles small and our load times fast.',permalink:"/post/async-loading-patterns-in-vue",readingTime:{text:"8 min read",minutes:7.965,time:477900,words:1593},slug:"async-loading-patterns-in-vue"}}}]);
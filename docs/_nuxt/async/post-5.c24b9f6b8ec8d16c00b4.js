(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{262:function(e,n){e.exports={title:"Nested Reactive Forms in Angular2, Continued",author:"Matt Brophy",postDate:"2017-02-09 12:34",tags:"angular,javascript,functional,reactive,frp",__content:'<p>If you haven&#39;t read <a href="/post/nested-reactive-forms-in-angular2/" title="Nested Reactive Forms in Angular2">Part 1</a> of this post, I suggest you jump over and check that out first, or else you may find yourself lost in the advanced operations we&#39;ll be discussing here.  In this post, we&#39;re going to look at more advanced usages of this setup, including form submission, adding/removing children, autosaving, undo/redo, and resetting form state.</p>\n<h2 id="recap">Recap</h2>\n<p>To recap, the final final architecture from <a href="/post/nested-reactive-forms-in-angular2/" title="Nested Reactive Forms in Angular2">Part 1</a> resulted in:</p>\n<ul>\n<li>A <code>ParentFormComponent</code> who knows only about root level <code>ParentData</code> fields and how to prompt for them in inputs, nothing about it&#39;s children&#39;s structures or forms</li>\n<li>A <code>ChildListComponent</code> who knows only about an array of children, and is responsible for managing the array, but not the contents or the associated forms</li>\n<li>A <code>ChildFormComponent</code> who knows only about it&#39;s own root level <code>ChildData</code> fields, and simply attaches it&#39;s own form to the incoming <code>FormArray</code></li>\n</ul>\n<h2 id="advanced-usage">Advanced Usage</h2>\n<p>Now that we have the basic setup, let&#39;s look at some of the more advanced features and how easy it can be to wire them up into this structure.</p>\n<h3 id="adding-a-new-child">Adding a new child</h3>\n<p>Adding a new child deals with modifying the array of children, so the responsibility falls on the <code>ChildListComponent</code>.  Let&#39;s look at the previously withheld <code>addChild</code> method in the component:</p>\n<pre><code class="hljs typescript"><span class="hljs-comment">// child-list.component.ts</span>\naddChild() {\n    <span class="hljs-keyword">const</span> child: ChildData = {\n        id: <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">100</span>),\n        childField1: <span class="hljs-string">\'\'</span>,\n        childField2: <span class="hljs-string">\'\'</span>,\n        childHiddenField1: <span class="hljs-string">\'\'</span>\n    };\n\n    <span class="hljs-keyword">this</span>.children.push(child);\n    <span class="hljs-keyword">this</span>.cd.detectChanges();\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n}</code></pre>\n<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- child-list.component.html --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">""</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"addChild()"</span>&gt;</span>\n    Add Child\n<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre>\n<p>To add a child, we simply need to add it to the data model array of children.  Note that we don&#39;t need to adjust the <code>FormArray</code>, because as soon as we add it to the data model array, our <code>*ngFor=&quot;let child of children&quot;</code> will update, causing the generation of a new <code>app-child-form</code>, which will internally create the form and add it to the <code>FormArray</code>.</p>\n<p>Note that we do have to call <code>detectChanges()</code>.  Without this, Angular complains because we&#39;ve just modified the children array, which in turn adds a new <code>FormControl</code> to the <code>children: FormArray</code>.  Because the initial values here are blank, and the fields are required in the <code>childForm: FormGroup</code>, this causes the <code>parentForm</code> to become invalidated.  Without triggering change detection, Angular (in dev mode) notices and complains that the <code>parentForm.valid</code> field changes from <code>true</code> to <code>false</code> and it was unaware.  Again - global form validity awareness.</p>\n<h3 id="removing-a-child">Removing a child</h3>\n<pre><code class="hljs typescript"><span class="hljs-comment">// child-list.component.ts</span>\nremoveChild(idx: <span class="hljs-built_in">number</span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.children.length &gt; <span class="hljs-number">1</span>) {\n        <span class="hljs-keyword">this</span>.children.splice(idx, <span class="hljs-number">1</span>);\n        (&lt;FormArray&gt;<span class="hljs-keyword">this</span>.parentForm.get(<span class="hljs-string">\'children\'</span>)).removeAt(idx);\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n}</code></pre>\n<p>This is the opposite of the add child behavior, in that we need to remove the child from the <code>children: ChildData[]</code> array.  However, there&#39;s one more step here to remove it from the <code>children: FormArray</code> as well.  As soon as we remove it from the data model array, the <code>ngFor</code> handles removing it&#39;s istance of <code>&lt;app-child-form&gt;</code>, but since we&#39;ve previously added the child form to the <code>FormArray</code>, it&#39;s left hanging there attached to the <code>parentForm</code> if we don&#39;t remove it.</p>\n<h3 id="submitting-the-parent-form">Submitting the Parent Form</h3>\n<p>Now that the entire form is wired up, the last thing we need to do it handle submission of the form.  Let&#39;s look first at the markup:</p>\n<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- parent-form.component.html --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">form</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"parentForm"</span>\n      (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">"onSubmit()"</span>&gt;</span>\n\n    <span class="hljs-comment">&lt;!-- inputs and child-list --&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> [<span class="hljs-attr">disabled</span>]=<span class="hljs-string">"!parentForm.valid"</span>&gt;</span>\n        Submit\n    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre>\n<p>We&#39;ll look at the <code>onSubmit</code> function in one second, but the <code>disabled</code> attribute usage here is really handy.  Because all of the nested components attached directly to the parent form, the <code>parentForm.valid</code> field will be updated in real-time based on <em>the entire form</em>, not just the inputs generated by the <code>ParentFormComponent</code>.  So when we null out an input way down in a child, the button immediately disables.  When we add a new child with empty initial values, the button immediately disables.  Only to re-enable as soon as all validations are satisfied.</p>\n<p>Finally, submitting the form is quite simple:</p>\n<pre><code class="hljs typescript"><span class="hljs-comment">// parent-form.component.ts</span>\nonSubmit() {\n    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.parentForm.valid) {\n        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">\'Parent Form invalid, preventing submission\'</span>);\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n    }\n\n    <span class="hljs-keyword">const</span> updatedParentData = _.mergeWith(<span class="hljs-keyword">this</span>.parentData,\n                                          <span class="hljs-keyword">this</span>.parentForm.value,\n                                          <span class="hljs-keyword">this</span>.mergeCustomizer);\n\n    <span class="hljs-comment">// ... send updatedParentData off to your REST API and go get a beer</span>\n\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n}</code></pre>\n<p>This is where the built in <code>ReactiveForms</code> functionality comes in super handy.  For any <code>FormGroup</code>, you can access it&#39;s current state of the inputs via <code>parentForm.value</code>, which will be an object matching the structure set up using your <code>FormGroup</code>/<code>FormArray</code>/<code>FormControl</code> objects.  If you noticed throughout, we&#39;ve matched all of our <code>FormControl</code> names to exactly the fields in our <code>ParentData</code>/<code>ChildData</code> objects - which means the resulting for <code>value</code> will be the same structure, and we can simply merge the data directly into our data model and send it off.</p>\n<p>The use of a specialized <code>mergeCustomizer</code> is needed because, IIRC, the default behavior of LoDash&#39;s <code>_.merge</code> function is to blow away the old array with the new array.  However, in our case where we have an array of child objects, we have to consider that we may not expose all fields into our child <code>FormGroup</code>.  For example, we&#39;re not going to let users edit the <code>id</code> or potentially <code>firstAdded</code>/<code>lastModified</code> or other metadata about the child object.  Therefore, our child <code>FormGroup</code> may only contain a subset of the fields of the original <code>ChildData</code> we generated a form for.  So we need to find the original child object by id, where it exists, and merge into that to preserve fields not included in the forms.</p>\n<pre><code class="hljs typescript"><span class="hljs-keyword">private</span> mergeCustomizer = <span class="hljs-function">(<span class="hljs-params">objValue, srcValue</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span> (_.isArray(objValue)) {\n        <span class="hljs-keyword">if</span> (_.isPlainObject(objValue[<span class="hljs-number">0</span>]) || _.isPlainObject(srcValue[<span class="hljs-number">0</span>])) {\n            <span class="hljs-comment">// If we found an array of objects, take our form values, and </span>\n            <span class="hljs-comment">// attempt to merge them into existing values in the data model, </span>\n            <span class="hljs-comment">// defaulting back to new empty object if none found.</span>\n            <span class="hljs-keyword">return</span> srcValue.map(<span class="hljs-function"><span class="hljs-params">src</span> =&gt;</span> {\n                <span class="hljs-keyword">const</span> obj = _.find(objValue, { id: src.id });\n                <span class="hljs-keyword">return</span> _.mergeWith(obj || {}, src, <span class="hljs-keyword">this</span>.mergeCustomizer);\n            });\n        }\n        <span class="hljs-keyword">return</span> srcValue;\n    }\n}</code></pre>\n<h2 id="super-advanced---autosaveundoredoreset">Super Advanced - autosave/undo/redo/reset</h2>\n<p>Last but not least, the functionality of <code>ReactiveForms</code> makes it pretty trivial to begin to think about handling more advanced form interactions:</p>\n<ul>\n<li>Autosaving drafts of the form periodically, without the user having to click submit</li>\n<li>Undo/redo to step forward and backward one edit at a time</li>\n<li>Resetting the entire form to it&#39;s initial state</li>\n</ul>\n<p>None of these are wired up in the example, but let&#39;s look at how we might try to wire them up in the <code>ParentFormComponent</code></p>\n<h3 id="autosaving">Autosaving</h3>\n<p>To autosave, we need to track changes as they happen.  Conveniently, ReactiveForms do just that using an <code>Observable</code> to which you can subscribe to be notified with the new form value on every single change.  Here, we can grab a full version of the <code>parentForm</code> after each change, and consider sending it off to our API in a draft state:</p>\n<pre><code class="hljs typescript"><span class="hljs-comment">// parent-form.component.ts</span>\nngAfterViewInit() {\n    <span class="hljs-keyword">this</span>.parentForm.valueChanges\n        .subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {\n            <span class="hljs-keyword">const</span> autosaveData = _.mergeWith(<span class="hljs-keyword">this</span>.parentData,\n                                             value,\n                                             <span class="hljs-keyword">this</span>.mergeCustomizer);\n            <span class="hljs-comment">// ... send to the API as a new draft revision</span>\n        });\n}</code></pre>\n<h3 id="undoredo">Undo/Redo</h3>\n<p>To begin implementing an undo operation, we&#39;d need to save off version of the form at each step, that we could re-initialize back to if the user wanted to undo:</p>\n<pre><code class="hljs typescript"><span class="hljs-comment">// parent-form.component.ts</span>\n<span class="hljs-keyword">private</span> undoStates: ParentData[] = [];\n\nngAfterViewInit() {\n    <span class="hljs-keyword">this</span>.parentForm.valueChanges\n        .subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {\n            <span class="hljs-keyword">const</span> currentState = _.mergeWith(<span class="hljs-keyword">this</span>.parentData,\n                                             value,\n                                             <span class="hljs-keyword">this</span>.mergeCustomizer)\n            undoStates.push(currentState);\n            <span class="hljs-comment">// ... Now, to perform an "undo" we could theoretically just </span>\n            <span class="hljs-comment">// re-populate the entire form with any entry from undoStates</span>\n        });\n}\n\nundo() {\n    <span class="hljs-keyword">this</span>.parentData = undoStates.pop();\n    <span class="hljs-comment">// At this point, there would need to be some cleanup performed on </span>\n    <span class="hljs-comment">// existing formControls.  Similar to how we removed the FormArray entry </span>\n    <span class="hljs-comment">// when we removed a config, if this undoState was going back to a </span>\n    <span class="hljs-comment">// smaller number of children - we\'d need to find a way to get the </span>\n    <span class="hljs-comment">// stale child FormControls removed from the child FormArray</span>\n}</code></pre>\n<p>Redo would be a little more complex, and would involve not popping an undoState off, but maintaining an index into the undo State that could be moved forward and backwards.</p>\n<h3 id="resetting-the-entire-form-to-its-initial-state">Resetting the entire form to it&#39;s initial state</h3>\n<p>This could be pretty easily tied in with the <code>undoStates</code> above, and reverting the user back to <code>undoStates[0]</code>.  But without worrying about undo/redo, it can be even simpler if we simply cache off a version of the form when we first render:</p>\n<pre><code class="hljs typescript"><span class="hljs-comment">// parent-form.component.ts</span>\n<span class="hljs-keyword">private</span> initialData: ParentData;\n\nngOnInit() {\n    <span class="hljs-comment">// Cache off the initial state</span>\n    <span class="hljs-keyword">this</span>.initialState = <span class="hljs-keyword">this</span>.getParentData();\n    <span class="hljs-comment">// Generate our initial form from a clone</span>\n    <span class="hljs-keyword">this</span>.parentData = _.cloneDeep(<span class="hljs-keyword">this</span>.initialState);\n    <span class="hljs-keyword">this</span>.parentForm = <span class="hljs-keyword">this</span>.toFormGroup(<span class="hljs-keyword">this</span>.parentData);\n}\n\nreset() {\n    <span class="hljs-keyword">this</span>.parentData = _.cloneDeep(<span class="hljs-keyword">this</span>.initialState);\n    <span class="hljs-comment">// Same logic applies here for cleaning up `FormControls` as needed</span>\n}</code></pre>\n<h2 id="summary">Summary</h2>\n<p>In the end, I was pleasantly surprised with how easy Angular2&#39;s new <code>ReactiveForms</code> module made it to manage form logic in controllers instead of templates, and how easy it made it to separate business logic from templates and across components.  I&#39;m sure there&#39;s further improvements that could be made on this architecture, but for a first pass over about 2 days, I was really excited how easy it was to build a multiple-level nested form over a fairly complex data structure.  Comments aren&#39;t yet wired up on this blog (only so many hours in a day), but feel free to reach out to me on <a href="http://www.twitter.com/brophdawg11" title="@brophdawg11">Twitter</a> with any comments or suggestions.  Thanks for reading!</p>\n',excerpt:'If you haven&apos;t read <a href="/post/nested-reactive-forms-in-angular2/" title="Nested Reactive Forms in Angular2">Part 1</a> of this post, I suggest you jump over and check that out first, or else you may find yourself lost in the advanced operations we&apos;ll be discussing here.  In this post, we&apos;re going to look at more advanced usages of this setup, including form submission, adding/removing children, autosaving, undo/redo, and resetting form state.',permalink:"/post/nested-reactive-forms-in-angular2-continued",readingTime:{text:"9 min read",minutes:8.415,time:504900,words:1683},slug:"nested-reactive-forms-in-angular2-continued"}}}]);
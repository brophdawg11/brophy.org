<!doctype html>
<html data-n-head-ssr lang="en" data-n-head="lang">
  <head data-n-head="">
    <title data-n-head="true">Matt Brophy's Personal Website</title><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="true" data-hid="description" name="description" content="Matt Brophy's Personal Website"><meta data-n-head="true" http-equiv="x-ua-compatible" content="ie=edge"><meta data-n-head="true" name="apple-mobile-web-app-capable" content="yes"><meta data-n-head="true" name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta data-n-head="true" name="apple-mobile-web-app-title" content="brophy.org"><meta data-n-head="true" data-hid="mobile-web-app-capable" name="mobile-web-app-capable" content="yes"><meta data-n-head="true" data-hid="author" name="author" content="Matt Brophy"><meta data-n-head="true" data-hid="theme-color" name="theme-color" content="black"><meta data-n-head="true" data-hid="og:type" name="og:type" property="og:type" content="website"><meta data-n-head="true" data-hid="og:title" name="og:title" property="og:title" content="brophy.org"><meta data-n-head="true" data-hid="og:site_name" name="og:site_name" property="og:site_name" content="brophy.org"><meta data-n-head="true" data-hid="og:description" name="og:description" property="og:description" content="Matt Brophy's Personal Website"><link data-n-head="true" rel="manifest" href="/manifest.json"><link data-n-head="true" rel="icon" type="image/x-icon" href="/favicon/favicon.ico"><link data-n-head="true" rel="shortcut icon" type="image/x-icon" href="/favicon/favicon.ico"><link data-n-head="true" rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"><link data-n-head="true" rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"><link data-n-head="true" rel="apple-touch-icon" type="image/x-icon" sizes="57x57" href="/favicon/apple-touch-icon-57x57.png"><link data-n-head="true" rel="apple-touch-icon" type="image/x-icon" sizes="60x60" href="/favicon/apple-touch-icon-60x60.png"><link data-n-head="true" rel="apple-touch-icon" type="image/x-icon" sizes="72x72" href="/favicon/apple-touch-icon-72x72.png"><link data-n-head="true" rel="apple-touch-icon" type="image/x-icon" sizes="76x76" href="/favicon/apple-touch-icon-76x76.png"><link data-n-head="true" rel="apple-touch-icon" type="image/x-icon" sizes="114x114" href="/favicon/apple-touch-icon-114x114.png"><link data-n-head="true" rel="apple-touch-icon" type="image/x-icon" sizes="120x120" href="/favicon/apple-touch-icon-120x120.png"><link data-n-head="true" rel="apple-touch-icon" type="image/x-icon" sizes="144x144" href="/favicon/apple-touch-icon-144x144.png"><link data-n-head="true" rel="apple-touch-icon" type="image/x-icon" sizes="152x152" href="/favicon/apple-touch-icon-152x152.png"><link data-n-head="true" rel="apple-touch-icon" type="image/x-icon" sizes="167x167" href="/favicon/apple-touch-icon-167x167.png"><link data-n-head="true" rel="apple-touch-icon" type="image/x-icon" sizes="180x180" href="/favicon/apple-touch-icon-180x180.png"><link data-n-head="true" rel="icon" type="image/png" sizes="192x192" href="/favicon/android-chrome-192x192.png"><link rel="preload" href="/_nuxt/runtime.e803325abfd56b48e81b.js" as="script"><link rel="preload" href="/_nuxt/async/commons.app.818c68e7fc8bb0f5bf2d.js" as="script"><link rel="preload" href="/_nuxt/async/app.66828c9f8a8e67467d36.js" as="script"><link rel="preload" href="/_nuxt/async/pages/post/_slug.d851e136b06223941c64.js" as="script"><style data-vue-ssr-id="8b5acbe2:0 452097a8:0 17cfdfa9:0 132df51d:0 95822e54:0 4effc658:0 745b4ac0:0 27df31d4:0 58764380:0">@font-face{font-family:icon-font;font-display:fallback;src:url(/_nuxt/fonts/02c7d2c.woff) format("woff");font-weight:400;font-style:normal}[class*=" fa-"]:before,[class^=fa-]:before{font-family:icon-font;font-style:normal;font-weight:400;speak:none;display:inline-block;text-decoration:inherit;width:1em;margin-right:.2em;text-align:center;-webkit-font-feature-settings:normal;font-feature-settings:normal;font-variant:normal;text-transform:none;line-height:1em;margin-left:.2em;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-home:before{content:"\e800"}.fa-chat:before{content:"\e801"}.fa-left-big:before{content:"\e802"}.fa-right-big:before{content:"\e803"}.fa-twitter:before{content:"\f099"}.fa-facebook:before{content:"\f09a"}.fa-github-circled:before{content:"\f09b"}.fa-gplus:before{content:"\f0d5"}.fa-angle-double-right:before{content:"\f101"}.fa-rss-squared:before{content:"\f143"}.fa-doc-text-inv:before{content:"\f15c"}.fa-instagram:before{content:"\f16d"}a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:"";content:none}table{border-collapse:collapse;border-spacing:0}@font-face{font-family:system;font-style:normal;font-weight:300;src:local(".SFNSText-Light"),local(".HelveticaNeueDeskInterface-Light"),local(".LucidaGrandeUI"),local("Ubuntu Light"),local("Segoe UI Light"),local("Roboto-Light"),local("DroidSans"),local("Tahoma")}body{font-family:system}*{box-sizing:border-box}body{font-size:100%;color:#181818}body,h1{font-family:"PT Serif",serif}h1{font-size:1.5rem;font-weight:700;margin:.67rem 0}@media (min-width:768px){h1{font-size:2rem}}h2{font-family:"PT Serif",serif;font-size:1.25rem;font-weight:700;margin:.75rem 0}@media (min-width:768px){h2{font-size:1.6rem}}h3{font-family:"PT Serif",serif;font-size:1rem;font-weight:700;margin:.83rem 0}@media (min-width:768px){h3{font-size:1.4rem}}h4{font-family:"PT Serif",serif;font-size:.83rem;font-weight:700;margin:1rem 0}@media (min-width:768px){h4{font-size:1.2rem}}pre{font-family:monospace;overflow-y:hidden;overflow-x:auto}a{color:#aa5d00;text-decoration:none;cursor:pointer}a:hover{text-decoration:underline}.nuxt-progress{background-color:#fff;height:5px}@media (min-width:1024px){.nuxt-progress{left:384px;background-color:#aa5d00}}.nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;opacity:1;transition:width .1s,opacity .4s;background-color:#000;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}.page-aside{background-position:50% 50%;background-size:cover;height:150px;background-image:url(/_nuxt/img/f09bc75.jpg)}@media screen and (min-width:768px){.page-aside{background-image:url(/_nuxt/img/d5754ab.jpg)}}@media screen and (min-width:1024px){.page-aside{position:fixed;top:0;left:0;bottom:0;width:384px;height:100%;background-image:url(/_nuxt/img/7cb7e48.jpg)}}.page-content-wrapper{display:flex;flex-direction:column;position:relative;padding:2em}@media screen and (min-width:1024px){.page-content-wrapper{padding:2em 0;margin-left:calc(384px + 2em);width:calc(100% - 384px - 4em);min-height:100vh}}.page-content{width:100%;max-width:768px;margin:auto;padding-bottom:2em;flex:1;display:flex;flex-direction:column;justify-content:center}.page-header{position:absolute;top:-75px;left:0;right:0;padding-bottom:2em;text-align:center}@media screen and (min-width:1024px){.page-header{position:relative;top:0}}.page-footer{padding-top:2em;text-align:center}.page-footer-nav{text-align:center;font-size:.75em}.s-footer-links.page-links__ul{padding-bottom:2em}.s-footer-links .page-link__li{margin:1.5em .75em}@media screen and (min-width:500px){.s-footer-links .page-link__li{margin:1em}}.page-links__ul{text-align:center;color:#aa5d00}.page-link__li{display:inline-block;margin:1em}@media screen and (min-width:1024px){.page-link__li{position:relative}}.page-link__a{background-color:#fafafa;border:2px solid #aa5d00;border-radius:50%;transition:all .2s;padding:1.25em .7em 1em;text-decoration:none;font-family:system,sans-serif}.page-link__a .fa{font-size:1.5em}.page-link__a:active,.page-link__a:hover,.page-link__a:link,.page-link__a:visited{color:inherit;text-decoration:none}.page-link__a:focus,.page-link__a:hover{background-color:#aa5d00;color:#fafafa}@media screen and (min-width:1024px){.page-link__a:focus .page-link__p,.page-link__a:hover .page-link__p{opacity:1}}.page-link__p{display:none}@media screen and (min-width:1024px){.page-link__p{display:block;color:#aa5d00;opacity:0;position:absolute;bottom:0;width:150%;margin-bottom:-3em;margin-left:-25%;text-align:center;left:0;right:0;transition:opacity .2s;font-size:.8em}}.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}.c-post__title{margin-bottom:10px}.c-post__meta{font-size:.9em;font-style:italic;margin-bottom:2em}.c-post__date{font-style:italics}.c-post__content{font-size:1.15em;line-height:1.75em}.c-post__content p{font-size:.9em;line-height:1.5em;padding-bottom:2em}@media screen and (min-width:768px){.c-post__content p{font-size:1em}}.c-post__content p img{display:block;margin:0 auto;max-width:100%}.c-post__content li{font-size:.9em;line-height:1.5em}.c-post__content strong{font-weight:700}.c-post__content em{font-style:italic}.c-post__content code{padding:0 3px;font-family:monospace;background-color:#eee}.c-post__content pre{padding-bottom:2em;margin:0}@media screen and (min-width:768px){.c-post__content pre{margin-left:2em;margin-right:2em}}.c-post__content pre code{padding:1em;font-size:.9em;line-height:1.25em}.c-post__content blockquote{padding:1em;background-color:#eee;margin:0 0 2em;font-style:italic}@media screen and (min-width:768px){.c-post__content blockquote{margin-left:2em;margin-right:2em}}.c-post__content blockquote ol,.c-post__content blockquote ul{margin-left:40px;padding-bottom:2em}.c-post__content blockquote p:last-child{padding-bottom:0}.c-post__content ol,.c-post__content ul{margin-left:40px;margin-bottom:2em}.c-post__share{text-align:right;margin-bottom:2em}.c-post__share-lead-in{padding-bottom:.66667em}.c-post__share-medium .fa{padding:5px;border-radius:50%;transition:color .2s,background-color .2s}.c-post__share-medium .fa:focus,.c-post__share-medium .fa:hover{color:#fff;background-color:#aa5d00}.c-meta__line1{padding-bottom:.5rem}.c-meta__divider{padding:0 10px}.c-post-nav{display:flex}.c-post-nav__link{flex-grow:1}.c-post-nav__link--previous{padding-right:10px;text-align:left}.c-post-nav__link--next{padding-left:10px;text-align:right}.page-footer-line{line-height:1.5em;padding:.25em}</style>
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div><aside class="page-aside"><div class="page-aside-img-loader"></div></aside> <section class="page-content-wrapper"><header class="page-header"><nav><ul class="page-links__ul s-header-links"><li class="page-link__li"><a href="/" title="Home" class="page-link__a nuxt-link-active"><span class="fa fa-home"></span><span class="page-link__p">Home</span></a></li><li class="page-link__li"><a href="/posts/" title="Blog" class="page-link__a"><span class="fa fa-chat"></span><span class="page-link__p">Blog</span></a></li><li class="page-link__li"><a href="/resume/" title="Resume" class="page-link__a"><span class="fa fa-doc-text-inv"></span><span class="page-link__p">Resume</span></a></li></ul></nav></header> <div class="page-content"><article><header><h1 class="c-post__title">
            Nested Reactive Forms in Angular2
        </h1> <div class="c-post__meta"><div><p class="c-meta__line1"><span title="Feb 08, 2017" class="c-meta__date">
            a couple of years ago
        </span> <span class="c-meta__divider c-meta__divider--first">|</span> <span class="c-meta__readtime">12 min read</span></p> <p class="c-meta__line2"><span class="c-meta__tags">
            Tags:
            <a href="/tag/angular/" title="angular">angular</a>, <a href="/tag/javascript/" title="javascript">javascript</a>, <a href="/tag/functional/" title="functional">functional</a>, <a href="/tag/reactive/" title="reactive">reactive</a>, <a href="/tag/frp/" title="frp">frp</a><!----></span></p></div></div></header> <section class="c-post__content"><p>Over at <a href="http://www.urbn.com" title="URBN">URBN</a>, I recently worked on a little internal app that involved a fairly complex nested form UI.  Having only done limited Angular2 work thus far, mostly using <a href="https://angular.io/docs/ts/latest/guide/upgrade.html" title="NgUpgrade">NgUpgrade</a> against an existing Angular1 app, it was a great learning experience in some of the new form capabilities offered in Angular2.  However, I couldn't find many great examples involving nested forms that felt clean/maintainable/etc.  After a few days of hacking, I was pretty happy with what we ended up with, and super excited about the new <a href="https://angular.io/docs/ts/latest/guide/reactive-forms.html" title="Reactive Forms">Reactive Forms</a> in Angular2.  </p>
<p>Note that in this article, I've dumbed it all down to a simple nested example of dummy data.  Much simpler than what we were working with in the actual app, but a clear example of the pattern.</p>
<p><strong>TL;DR;</strong> For those that just want to check out the code:</p>
<ul>
<li>The sample code is all up on <a href="https://github.com/brophdawg11/ng-playground/tree/master/src/app/nested-forms" title="Nested Forms on GitHub">GitHub</a></li>
<li>A live demo is available via <a href="https://brophdawg11.github.io/ng-playground/nested-form" title="Nested Forms Demo">GitHub-Pages</a></li>
<li>I also dumped it all into a <a href="https://plnkr.co/edit/9Lqv7uXFMjhFDr932VG2?p=preview" title="Plnkr">Plnkr</a> for easy tweaking</li>
</ul>
<h2 id="template-driven-forms-in-angular-1">Template Driven Forms in Angular 1</h2>
<p>Angular1 used a very template-driven approach to forms, so you'd see something like:</p>
<pre><code class="hljs javascript">$scope.data = {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">''</span>
}</code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ng-model</span>=<span class="hljs-string">"data.firstName"</span>
       <span class="hljs-attr">ng-required</span>=<span class="hljs-string">"true"</span>
       <span class="hljs-attr">ng-maxlength</span>=<span class="hljs-string">"40"</span>
       <span class="hljs-attr">ng-pattern</span>=<span class="hljs-string">"^[a-zA-Z ]*"</span> /></span></code></pre>
<p>Admittedly, it was pretty slick as it provided real-time validation, error messages, etc. via the <code>FormController</code>.  However, as the complexities of your form grew, the amount of logic living in the templates grew as well, making it harder to maintain, unit test, etc.  Although I never used them directly, libraries like <a href="http://angular-formly.com/" title="Angular Formly">Angular Formly</a> arose that tried to deal with this by moving logic out of the template and into the controller.</p>
<h2 id="template-driven-forms-in-angular-2">Template Driven Forms in Angular 2</h2>
<p>Along came Angular 2, and they kept a very similar pattern with their <code>FormsModule</code>:</p>
<pre><code class="hljs typescript"><span class="hljs-meta">@Component</span>(...)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> TemplateDrivenForm {
    data: <span class="hljs-built_in">Object</span> = {
        firstName: <span class="hljs-string">''</span>
    };
}</code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"data.firstName"</span> 
       <span class="hljs-attr">required</span>
       <span class="hljs-attr">maxlength</span>=<span class="hljs-string">"40"</span>
       <span class="hljs-attr">pattern</span>=<span class="hljs-string">"^[a-zA-Z ]*"</span> /></span></code></pre>
<p>You'll notice they kept <code>ngModel</code>, but now support the native HTML5 input validation attributes - Neat!  However, this comes along with many of the same problems as the Angular 1 <code>ng-model</code> approach - as your form grows, your templates grow, and validation logic still lives mainly in the template.</p>
<h2 id="reactive-forms-in-angular-2">Reactive Forms in Angular 2</h2>
<p>Enter the Angular 2 <a href="https://angular.io/docs/ts/latest/guide/reactive-forms.html" title="Reactive Forms">Reactive Forms</a> module.  I'll save you the details, but the main advantage as I see it, is moving the majority of your form logic, including validation, into your Components.  This completely takes the template out of the equation and leaves you with self-contained, easily-testable components.  For additional reading, here are a few of the articles I found most helpful when I was getting up to speed:</p>
<ul>
<li><a href="http://blog.angular-university.io/introduction-to-angular-2-forms-template-driven-vs-model-driven/" title="Template Driven vs Model Driven or Reactive Forms">Template Driven vs Model Drive or Reactive Forms</a></li>
<li><a href="https://blog.thoughtram.io/angular/2016/06/22/model-driven-forms-in-angular-2.html" title="Reactive Forms in Angular">Reactive Forms in Angular</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/reactive-forms.html" title="Reactive Forms">Angular2 Documentation for ReactiveForms</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/dynamic-form.html" title="Dynamic Forms">Angular2 Cookbook for Dynamic Forms</a></li>
</ul>
<h2 id="nested-reactive-forms">Nested Reactive Forms</h2>
<p>Now that you're an expert in Reactive Forms from the above articles, we'll walk through the architecture we landed on, while noting some of the downsides of existing approaches we were able to find on the web.  Note that example code has been stripped down to the bare essentials for readability - please refer to the code on <a href="https://github.com/brophdawg11/ng-playground/tree/master/src/app/nested-forms" title="Nested Forms on GitHub">GitHub</a> or <a href="https://plnkr.co/edit/9Lqv7uXFMjhFDr932VG2?p=preview" title="Plnkr">Plnkr</a> for the full examples.</p>
<p>Here's the data structure we'll be using for our simple nested form:</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ParentData {
    parentField1: <span class="hljs-built_in">string</span>;
    parentField2: <span class="hljs-built_in">string</span>;
    parentHiddenField1: <span class="hljs-built_in">string</span>;
    children: ChildData[];
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ChildData {
    id: <span class="hljs-built_in">number</span>;
    childField1: <span class="hljs-built_in">string</span>;
    childField2: <span class="hljs-built_in">string</span>;
    childHiddenField1: <span class="hljs-built_in">string</span>;
};
</code></pre>
<p>Super simple.  A parent object which contains an array of child objects.  In the end, we want a single form that allows us to view and edit the entire nested structure, including adding/removing children.  Note that my actual app contained additional levels of nesting, but this pattern is easily extendable to meet additional levels.</p>
<p>The first example I came across was a post on <a href="https://scotch.io/tutorials/how-to-build-nested-model-driven-forms-in-angular-2" title="Nested Forms in Angular2">Scotch.io</a>, which does a nice job of building the nested for in a single component, and then walking through pulling out the nested component.  This seemed pretty close to what we were looking for, and was actually quite close to what I had come up with in my first attempt, prior to abstracting out nested components.  However, there were a two main downsides to this approach in my opinion:</p>
<ul>
<li>In this final example, the template for the nested address form is moved down to an <code>AddressComponent</code>, but <em>all</em> of the logic regarding <em>"What does an address look like"</em> remains in the parent <code>AppComponent</code>.  This includes what an address data model looks like, as well as how to build an address <code>FormGroup</code> and all associated validations.  This seemed messy (and it gets called out by multiple people in the comments).  What's the point of abstracting the logic out if the parent component still has to maintain all of the knowledge about an address?</li>
<li>The final little template section using <code>[formGroupName]="i"</code> and <code>&lt;address [group]="myForm.controls.addresses.controls[i]">&lt;/address></code> seemed messy.  The <code>formGroupName</code> seemed a little black-magic to me.  In my first construction of my app, I was using those to track <code>FormArray</code>'s, and it just felt...odd.</li>
</ul>
<p>So I set out to see if I could clean this up, with a few goals in mind (according to our Parent/Child data structure above):</p>
<ul>
<li>The parent component shouldn't need to know about the structure of it's children.  Not the data model, not the form setup, validations, how to create/remove.  Nothing</li>
<li>A single component should worry only about managing it's root level fields.  This goes for a parent and a child</li>
<li>The parent component should, however, be acutely aware of the validity of the entire form, including all nested forms, so as to prevent submission on invalid root-level and nested user inputs</li>
<li>A child component should only be required to set up a form for a single child data model.  It should not be responsible for adding/removing sibling children</li>
</ul>
<p>So, where did I land?  the end architecture was basically:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">parent-form</span>></span>
    <span class="hljs-tag">&lt;<span class="hljs-name">child-list</span>></span>
        <span class="hljs-tag">&lt;<span class="hljs-name">child-form</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let child of children"</span>></span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">child-form</span>></span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">child-list</span>></span>
<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>></span></code></pre>
<p>Let's take a look at them in some detail.</p>
<h3 id="parent-form-component">Parent Form Component</h3>
<p>The parent form component, as stated in the above goals, should focus solely on the <code>ParentData</code> object.  Here's how that looks:</p>
<pre><code class="hljs typescript"><span class="hljs-comment">// parent-form.component.ts</span>
<span class="hljs-meta">@Component</span>({
    selector: <span class="hljs-string">'app-parent-form'</span>,
    templateUrl: <span class="hljs-string">'./parent-form.component.html'</span>,
    styleUrls: [ <span class="hljs-string">'./parent-form.component.css'</span> ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ParentFormComponent <span class="hljs-keyword">implements</span> OnInit, AfterViewInit {
    <span class="hljs-keyword">public</span> parentData: ParentData;
    <span class="hljs-keyword">public</span> parentForm: FormGroup;

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> fb: FormBuilder</span>) {}

    ngOnInit() {
        <span class="hljs-keyword">this</span>.parentData = <span class="hljs-keyword">this</span>.getParentData();
        <span class="hljs-keyword">this</span>.parentForm = <span class="hljs-keyword">this</span>.toFormGroup(<span class="hljs-keyword">this</span>.parentData);
    }

    <span class="hljs-keyword">private</span> getParentData(): ParentData {
        <span class="hljs-comment">// Insert mock object here.  Likely provided via a resolver in a </span>
        <span class="hljs-comment">// real world scenario</span>
        <span class="hljs-keyword">return</span> { ... };
    }

    <span class="hljs-keyword">private</span> toFormGroup(data: ParentData): FormGroup {
        <span class="hljs-keyword">const</span> formGroup = <span class="hljs-keyword">this</span>.fb.group({
            parentField1: [ data.parentField1, Validators.required ],
            parentField2: [ data.parentField2, Validators.required ],
            parentHiddenField1: [ data.parentHiddenField1 ]
        });

        <span class="hljs-keyword">return</span> formGroup;
    }
}</code></pre>
<p>That seems pretty close to what we wanted.  It knows about a <code>ParentData</code> object, and it knows how to generate a <code>FormGroup</code> for the root-level fields of the <code>ParentData</code>.  Form validation is all contained in the component, making for easy isolated unit testing of form validation logic.  </p>
<p>Now, the template:</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- parent-form.component.html --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">form</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"parentForm"</span>></span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"parentField1"</span>></span>Parent Field 1<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>></span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"parentField1"</span> /></span>

    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/></span>

    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"parentField2"</span>></span>Parent Field 2<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>></span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"parentField2"</span> /></span>

    <span class="hljs-tag">&lt;<span class="hljs-name">app-child-list</span>
        [<span class="hljs-attr">parentForm</span>]=<span class="hljs-string">"parentForm"</span>
        [<span class="hljs-attr">children</span>]=<span class="hljs-string">"parentData.children"</span>></span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">app-child-list</span>></span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>></span></code></pre>
<p>That's it, we set up a few <code>FormControl</code>'s in our component above, and we just link them to inputs in the template.  Note the immediate simplicity of removing any <code>required</code>/<code>pattern</code>/<code>maxlength</code> attributes.  All of those can be specified via <code>Validators</code> in the <code>FormControl</code>.  </p>
<h3 id="child-list-component">Child List Component</h3>
<p>In order to prevent the parent from caring about it's children (that sounds bad - my parents are great - this is not a slight at them - I promise), we've delegated all of that down to a <code>ChildListComponent</code>, into which we pass our parent <code>FormGroup</code> and the array of <code>children</code>:</p>
<pre><code class="hljs typescript"><span class="hljs-comment">// child-list.component.ts</span>
<span class="hljs-meta">@Component</span>({ ... })
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ChildListComponent <span class="hljs-keyword">implements</span> OnInit {
    <span class="hljs-meta">@Input</span>(<span class="hljs-string">'parentForm'</span>)
    <span class="hljs-keyword">public</span> parentForm: FormGroup;

    <span class="hljs-meta">@Input</span>(<span class="hljs-string">'children'</span>)
    <span class="hljs-keyword">public</span> children: ChildData[];

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> cd: ChangeDetectorRef</span>) { }

    ngOnInit() {
        <span class="hljs-keyword">this</span>.parentForm.addControl(<span class="hljs-string">'children'</span>, <span class="hljs-keyword">new</span> FormArray([]));
    }
}</code></pre>
<p>Huh.  That's too simple, right?  I mean, what exactly does this do if it's literally this small?  In the simplest case, this list component is strictly in charge of managing an array of children.  It does not, at the moment, care what a <code>ChildData</code> object looks like, it just knows that it's an array, and therefore it initializes an empty <code>FormArray</code> and attaches it to the parent form.  That's a pretty key detail there though - remember the goal of the parent being <em>"acutely aware of the validity of the entire form"</em>?  By attaching a new <code>FormArray</code>  control directly to the parent form, we'll get direct access in the parent controller to a data structure like the following:</p>
<pre><code class="hljs typescript">parentForm.value = {
    parentField1: <span class="hljs-built_in">string</span>;
    parentField2: <span class="hljs-built_in">string</span>;
    children: []
}</code></pre>
<p>And that's without the parent component <code>FormGroup</code> doing anything with <code>children</code> or <code>FormArray</code>'s.  Cool, that seems like a nice separation of concerns.</p>
<p>So, now we look at the template for the <code>ChildListComponent</code>:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"parentForm"</span>></span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">formArrayName</span>=<span class="hljs-string">"children"</span>></span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let child of children"</span>></span>
            <span class="hljs-tag">&lt;<span class="hljs-name">app-child-form</span>
                [<span class="hljs-attr">children</span>]=<span class="hljs-string">"parentForm.controls.children"</span>
                [<span class="hljs-attr">child</span>]=<span class="hljs-string">"child"</span>></span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">app-child-form</span>></span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>
</code></pre>
<p>Again, that's super simple.  We're basically saying the following:</p>
<ul>
<li>I'm working within the <code>parentForm</code></li>
<li>I'm working on the <code>children</code> array of that form</li>
<li>For each of those children, instantiate an <code>&lt;app-child-form></code> component, into which I'll pass the <code>children: FormArray</code> and the <code>child: ChildData</code> objects into</li>
</ul>
<h3 id="child-form-component">Child Form Component</h3>
<pre><code class="hljs typescript"><span class="hljs-comment">// child-form.component.ts</span>
<span class="hljs-meta">@Component</span>({ ... })
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ChildFormComponent <span class="hljs-keyword">implements</span> OnInit {
    <span class="hljs-meta">@Input</span>(<span class="hljs-string">'children'</span>)
    <span class="hljs-keyword">public</span> children: FormArray;

    <span class="hljs-meta">@Input</span>(<span class="hljs-string">'child'</span>)
    <span class="hljs-keyword">public</span> child: ChildData;

    <span class="hljs-keyword">public</span> childForm: FormGroup;

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> fb: FormBuilder</span>) {}

    ngOnInit() {
        <span class="hljs-keyword">this</span>.childForm = <span class="hljs-keyword">this</span>.toFormGroup(<span class="hljs-keyword">this</span>.child);
        <span class="hljs-keyword">this</span>.children.push(<span class="hljs-keyword">this</span>.childForm);
    }

    <span class="hljs-keyword">private</span> toFormGroup(data: ChildData) {
        <span class="hljs-keyword">const</span> formGroup = <span class="hljs-keyword">this</span>.fb.group({
            id: [ data.id ],
            childField1: [ data.childField1 || <span class="hljs-string">''</span>, Validators.required ],
            childField2: [ data.childField2 || <span class="hljs-string">''</span>, Validators.required ],
            childHiddenField1: [ data.childHiddenField1 ]
        });

        <span class="hljs-keyword">return</span> formGroup;
    }
}</code></pre>
<p>Cool, now we're down to the nitty gritty of what a <code>ChildData</code> and it's associated form looks like.  Notice how this component has <em>no idea</em> of what a <code>ParentData</code> or <code>parentForm</code> object is?  That's good.  All this component should need to know how to do is (1) setup a <code>FormGroup</code> for it's <code>child</code> instance, and (2) attach that to the <code>children: FormArray</code> we got from the <code>ChildListComponent</code>.  This is again a key point.  Remember that the incoming <code>FormArray</code> has already been attached to the <code>parentForm</code> in the list component.  By attaching our childForm to the parent <code>FormArray</code>, we've attached it to the <code>parentForm</code>, which we actually know nothing about.  But it provides the <code>parentForm</code> awareness into the global validity of the entire form, all the way down to the child level.</p>
<p>And then, the final template:</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- child-form.component.html --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"childForm"</span>></span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"childField1"</span>></span>Child Field 1<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>></span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"childField1"</span> /></span>
    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/></span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"childField1"</span>></span>Child Field 2<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>></span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"childField2"</span> /></span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>
</code></pre>
<p>And that's it.  This child form template is, not surprisingly, setting up inputs for it's <code>FormControl</code>'s within it's own <code>childForm: formGroup</code>.</p>
<h3 id="summary">Summary</h3>
<p>So the final architecture and delegated responsibilities is:</p>
<ul>
<li>A <code>ParentFormComponent</code> who knows only about root level <code>ParentData</code> fields and how to prompt for them in inputs, nothing about it's children's structures or forms</li>
<li>A <code>ChildListComponent</code> who knows only about an array of children, and is responsible for managing the array, but not the contents or the associated forms</li>
<li>A <code>ChildFormComponent</code> who knows only about it's own root level <code>ChildData</code> fields, and simply attaches it's own form to the incoming <code>FormArray</code></li>
</ul>
<p>For more advanced usages of this setup, including form submission, adding/removing children, autosaving, undo/redo, and resetting form state - check out <a href="/post/nested-reactive-forms-in-angular2-continued/" title="Nested Reactive Forms in Angular2, Continued">the follow up post</a>.  Thanks for reading!</p>
</section> <footer><div class="c-post__share"><p class="c-post__share-lead-in">
                Enjoy this post?
            </p> <a href="https://twitter.com/share?text=Nested Reactive Forms in Angular2&amp;amp;url=https://brophy.org/post/nested-reactive-forms-in-angular2" class="c-post__share-medium">
                Share on Twitter
            </a>

            or

            <a href="https://twitter.com/search?q=https://brophy.org/post/nested-reactive-forms-in-angular2" target="_blank" rel="noopener noreferrer" class="c-post__share-medium">
                Discuss on Twitter
            </a></div> <div class="c-post-nav"><!----> <!----></div></footer></article></div> <footer class="page-footer"><nav class="page-footer-nav"><ul class="page-links__ul s-footer-links"><li class="page-link__li"><a href="https://www.github.com/brophdawg11" title="GitHub" target="_blank" rel="noopener" class="page-link__a"><span class="fa fa-github-circled"></span><span class="page-link__p">GitHub</span></a></li><li class="page-link__li"><a href="https://www.instagram.com/brophdawg11" title="Instagram" target="_blank" rel="noopener" class="page-link__a"><span class="fa fa-instagram"></span><span class="page-link__p">Instagram</span></a></li><li class="page-link__li"><a href="https://www.twitter.com/brophdawg11" title="Twitter" target="_blank" rel="noopener" class="page-link__a"><span class="fa fa-twitter"></span><span class="page-link__p">Twitter</span></a></li></ul></nav> <div><p class="page-footer-line">
        built with
        <a href="https://vuejs.org/" title="Vue" target="_blank" rel="noopener">
            vue
        </a>
        and
        <a href="https://nuxtjs.org/" title="Nuxt" target="_blank" rel="noopener">
            nuxt
        </a></p> <p class="page-footer-line">
        stored/hosted in
        <a href="https://www.github.com/brophdawg11/brophy.org" title="GitHub" target="_blank" rel="noopener">
            github
        </a>
        using
        <a href="https://pages.github.com/" title="Github Pages" target="_blank" rel="noopener">
            github pages
        </a></p> <p class="page-footer-line">
        side images from
        <a href="https://www.gratisography.com/" title="Gratisography" target="_blank" rel="noopener">
            gratisography
        </a></p> <p class="page-footer-line">
        icons from
        <a href="https://fontawesome.com/" title="Font-Awesome" target="_blank" rel="noopener">
            font-awesome
        </a>
        via
        <a href="http://fontello.com/" title="Fontello" target="_blank" rel="noopener">
            fontello
        </a></p> <p class="page-footer-line">
        © Copyright 2019 Matt Brophy
    </p></div></footer></section></div></div></div><script>window.__NUXT__=function(s,a){return{layout:"default",data:[[s,s]],error:null,state:{url:"https://brophy.org",title:a,description:"Matt Brophy's Website",rss:{title:"Matt Brophy's Blog"},pageSize:6,post:{title:"Nested Reactive Forms in Angular2",author:a,postDate:"2017-02-08 22:00",tags:"angular,javascript,functional,reactive,frp",__content:'<p>Over at <a href="http://www.urbn.com" title="URBN">URBN</a>, I recently worked on a little internal app that involved a fairly complex nested form UI.  Having only done limited Angular2 work thus far, mostly using <a href="https://angular.io/docs/ts/latest/guide/upgrade.html" title="NgUpgrade">NgUpgrade</a> against an existing Angular1 app, it was a great learning experience in some of the new form capabilities offered in Angular2.  However, I couldn&#39;t find many great examples involving nested forms that felt clean/maintainable/etc.  After a few days of hacking, I was pretty happy with what we ended up with, and super excited about the new <a href="https://angular.io/docs/ts/latest/guide/reactive-forms.html" title="Reactive Forms">Reactive Forms</a> in Angular2.  </p>\n<p>Note that in this article, I&#39;ve dumbed it all down to a simple nested example of dummy data.  Much simpler than what we were working with in the actual app, but a clear example of the pattern.</p>\n<p><strong>TL;DR;</strong> For those that just want to check out the code:</p>\n<ul>\n<li>The sample code is all up on <a href="https://github.com/brophdawg11/ng-playground/tree/master/src/app/nested-forms" title="Nested Forms on GitHub">GitHub</a></li>\n<li>A live demo is available via <a href="https://brophdawg11.github.io/ng-playground/nested-form" title="Nested Forms Demo">GitHub-Pages</a></li>\n<li>I also dumped it all into a <a href="https://plnkr.co/edit/9Lqv7uXFMjhFDr932VG2?p=preview" title="Plnkr">Plnkr</a> for easy tweaking</li>\n</ul>\n<h2 id="template-driven-forms-in-angular-1">Template Driven Forms in Angular 1</h2>\n<p>Angular1 used a very template-driven approach to forms, so you&#39;d see something like:</p>\n<pre><code class="hljs javascript">$scope.data = {\n    <span class="hljs-attr">firstName</span>: <span class="hljs-string">\'\'</span>\n}</code></pre>\n<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ng-model</span>=<span class="hljs-string">"data.firstName"</span>\n       <span class="hljs-attr">ng-required</span>=<span class="hljs-string">"true"</span>\n       <span class="hljs-attr">ng-maxlength</span>=<span class="hljs-string">"40"</span>\n       <span class="hljs-attr">ng-pattern</span>=<span class="hljs-string">"^[a-zA-Z ]*"</span> /&gt;</span></code></pre>\n<p>Admittedly, it was pretty slick as it provided real-time validation, error messages, etc. via the <code>FormController</code>.  However, as the complexities of your form grew, the amount of logic living in the templates grew as well, making it harder to maintain, unit test, etc.  Although I never used them directly, libraries like <a href="http://angular-formly.com/" title="Angular Formly">Angular Formly</a> arose that tried to deal with this by moving logic out of the template and into the controller.</p>\n<h2 id="template-driven-forms-in-angular-2">Template Driven Forms in Angular 2</h2>\n<p>Along came Angular 2, and they kept a very similar pattern with their <code>FormsModule</code>:</p>\n<pre><code class="hljs typescript"><span class="hljs-meta">@Component</span>(...)\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> TemplateDrivenForm {\n    data: <span class="hljs-built_in">Object</span> = {\n        firstName: <span class="hljs-string">\'\'</span>\n    };\n}</code></pre>\n<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"data.firstName"</span> \n       <span class="hljs-attr">required</span>\n       <span class="hljs-attr">maxlength</span>=<span class="hljs-string">"40"</span>\n       <span class="hljs-attr">pattern</span>=<span class="hljs-string">"^[a-zA-Z ]*"</span> /&gt;</span></code></pre>\n<p>You&#39;ll notice they kept <code>ngModel</code>, but now support the native HTML5 input validation attributes - Neat!  However, this comes along with many of the same problems as the Angular 1 <code>ng-model</code> approach - as your form grows, your templates grow, and validation logic still lives mainly in the template.</p>\n<h2 id="reactive-forms-in-angular-2">Reactive Forms in Angular 2</h2>\n<p>Enter the Angular 2 <a href="https://angular.io/docs/ts/latest/guide/reactive-forms.html" title="Reactive Forms">Reactive Forms</a> module.  I&#39;ll save you the details, but the main advantage as I see it, is moving the majority of your form logic, including validation, into your Components.  This completely takes the template out of the equation and leaves you with self-contained, easily-testable components.  For additional reading, here are a few of the articles I found most helpful when I was getting up to speed:</p>\n<ul>\n<li><a href="http://blog.angular-university.io/introduction-to-angular-2-forms-template-driven-vs-model-driven/" title="Template Driven vs Model Driven or Reactive Forms">Template Driven vs Model Drive or Reactive Forms</a></li>\n<li><a href="https://blog.thoughtram.io/angular/2016/06/22/model-driven-forms-in-angular-2.html" title="Reactive Forms in Angular">Reactive Forms in Angular</a></li>\n<li><a href="https://angular.io/docs/ts/latest/guide/reactive-forms.html" title="Reactive Forms">Angular2 Documentation for ReactiveForms</a></li>\n<li><a href="https://angular.io/docs/ts/latest/cookbook/dynamic-form.html" title="Dynamic Forms">Angular2 Cookbook for Dynamic Forms</a></li>\n</ul>\n<h2 id="nested-reactive-forms">Nested Reactive Forms</h2>\n<p>Now that you&#39;re an expert in Reactive Forms from the above articles, we&#39;ll walk through the architecture we landed on, while noting some of the downsides of existing approaches we were able to find on the web.  Note that example code has been stripped down to the bare essentials for readability - please refer to the code on <a href="https://github.com/brophdawg11/ng-playground/tree/master/src/app/nested-forms" title="Nested Forms on GitHub">GitHub</a> or <a href="https://plnkr.co/edit/9Lqv7uXFMjhFDr932VG2?p=preview" title="Plnkr">Plnkr</a> for the full examples.</p>\n<p>Here&#39;s the data structure we&#39;ll be using for our simple nested form:</p>\n<pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ParentData {\n    parentField1: <span class="hljs-built_in">string</span>;\n    parentField2: <span class="hljs-built_in">string</span>;\n    parentHiddenField1: <span class="hljs-built_in">string</span>;\n    children: ChildData[];\n};\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ChildData {\n    id: <span class="hljs-built_in">number</span>;\n    childField1: <span class="hljs-built_in">string</span>;\n    childField2: <span class="hljs-built_in">string</span>;\n    childHiddenField1: <span class="hljs-built_in">string</span>;\n};\n</code></pre>\n<p>Super simple.  A parent object which contains an array of child objects.  In the end, we want a single form that allows us to view and edit the entire nested structure, including adding/removing children.  Note that my actual app contained additional levels of nesting, but this pattern is easily extendable to meet additional levels.</p>\n<p>The first example I came across was a post on <a href="https://scotch.io/tutorials/how-to-build-nested-model-driven-forms-in-angular-2" title="Nested Forms in Angular2">Scotch.io</a>, which does a nice job of building the nested for in a single component, and then walking through pulling out the nested component.  This seemed pretty close to what we were looking for, and was actually quite close to what I had come up with in my first attempt, prior to abstracting out nested components.  However, there were a two main downsides to this approach in my opinion:</p>\n<ul>\n<li>In this final example, the template for the nested address form is moved down to an <code>AddressComponent</code>, but <em>all</em> of the logic regarding <em>&quot;What does an address look like&quot;</em> remains in the parent <code>AppComponent</code>.  This includes what an address data model looks like, as well as how to build an address <code>FormGroup</code> and all associated validations.  This seemed messy (and it gets called out by multiple people in the comments).  What&#39;s the point of abstracting the logic out if the parent component still has to maintain all of the knowledge about an address?</li>\n<li>The final little template section using <code>[formGroupName]=&quot;i&quot;</code> and <code>&lt;address [group]=&quot;myForm.controls.addresses.controls[i]&quot;&gt;&lt;/address&gt;</code> seemed messy.  The <code>formGroupName</code> seemed a little black-magic to me.  In my first construction of my app, I was using those to track <code>FormArray</code>&#39;s, and it just felt...odd.</li>\n</ul>\n<p>So I set out to see if I could clean this up, with a few goals in mind (according to our Parent/Child data structure above):</p>\n<ul>\n<li>The parent component shouldn&#39;t need to know about the structure of it&#39;s children.  Not the data model, not the form setup, validations, how to create/remove.  Nothing</li>\n<li>A single component should worry only about managing it&#39;s root level fields.  This goes for a parent and a child</li>\n<li>The parent component should, however, be acutely aware of the validity of the entire form, including all nested forms, so as to prevent submission on invalid root-level and nested user inputs</li>\n<li>A child component should only be required to set up a form for a single child data model.  It should not be responsible for adding/removing sibling children</li>\n</ul>\n<p>So, where did I land?  the end architecture was basically:</p>\n<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">parent-form</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">child-list</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">child-form</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let child of children"</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">child-form</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">child-list</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre>\n<p>Let&#39;s take a look at them in some detail.</p>\n<h3 id="parent-form-component">Parent Form Component</h3>\n<p>The parent form component, as stated in the above goals, should focus solely on the <code>ParentData</code> object.  Here&#39;s how that looks:</p>\n<pre><code class="hljs typescript"><span class="hljs-comment">// parent-form.component.ts</span>\n<span class="hljs-meta">@Component</span>({\n    selector: <span class="hljs-string">\'app-parent-form\'</span>,\n    templateUrl: <span class="hljs-string">\'./parent-form.component.html\'</span>,\n    styleUrls: [ <span class="hljs-string">\'./parent-form.component.css\'</span> ]\n})\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ParentFormComponent <span class="hljs-keyword">implements</span> OnInit, AfterViewInit {\n    <span class="hljs-keyword">public</span> parentData: ParentData;\n    <span class="hljs-keyword">public</span> parentForm: FormGroup;\n\n    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> fb: FormBuilder</span>) {}\n\n    ngOnInit() {\n        <span class="hljs-keyword">this</span>.parentData = <span class="hljs-keyword">this</span>.getParentData();\n        <span class="hljs-keyword">this</span>.parentForm = <span class="hljs-keyword">this</span>.toFormGroup(<span class="hljs-keyword">this</span>.parentData);\n    }\n\n    <span class="hljs-keyword">private</span> getParentData(): ParentData {\n        <span class="hljs-comment">// Insert mock object here.  Likely provided via a resolver in a </span>\n        <span class="hljs-comment">// real world scenario</span>\n        <span class="hljs-keyword">return</span> { ... };\n    }\n\n    <span class="hljs-keyword">private</span> toFormGroup(data: ParentData): FormGroup {\n        <span class="hljs-keyword">const</span> formGroup = <span class="hljs-keyword">this</span>.fb.group({\n            parentField1: [ data.parentField1, Validators.required ],\n            parentField2: [ data.parentField2, Validators.required ],\n            parentHiddenField1: [ data.parentHiddenField1 ]\n        });\n\n        <span class="hljs-keyword">return</span> formGroup;\n    }\n}</code></pre>\n<p>That seems pretty close to what we wanted.  It knows about a <code>ParentData</code> object, and it knows how to generate a <code>FormGroup</code> for the root-level fields of the <code>ParentData</code>.  Form validation is all contained in the component, making for easy isolated unit testing of form validation logic.  </p>\n<p>Now, the template:</p>\n<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- parent-form.component.html --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">form</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"parentForm"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"parentField1"</span>&gt;</span>Parent Field 1<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"parentField1"</span> /&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"parentField2"</span>&gt;</span>Parent Field 2<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"parentField2"</span> /&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-name">app-child-list</span>\n        [<span class="hljs-attr">parentForm</span>]=<span class="hljs-string">"parentForm"</span>\n        [<span class="hljs-attr">children</span>]=<span class="hljs-string">"parentData.children"</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">app-child-list</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre>\n<p>That&#39;s it, we set up a few <code>FormControl</code>&#39;s in our component above, and we just link them to inputs in the template.  Note the immediate simplicity of removing any <code>required</code>/<code>pattern</code>/<code>maxlength</code> attributes.  All of those can be specified via <code>Validators</code> in the <code>FormControl</code>.  </p>\n<h3 id="child-list-component">Child List Component</h3>\n<p>In order to prevent the parent from caring about it&#39;s children (that sounds bad - my parents are great - this is not a slight at them - I promise), we&#39;ve delegated all of that down to a <code>ChildListComponent</code>, into which we pass our parent <code>FormGroup</code> and the array of <code>children</code>:</p>\n<pre><code class="hljs typescript"><span class="hljs-comment">// child-list.component.ts</span>\n<span class="hljs-meta">@Component</span>({ ... })\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ChildListComponent <span class="hljs-keyword">implements</span> OnInit {\n    <span class="hljs-meta">@Input</span>(<span class="hljs-string">\'parentForm\'</span>)\n    <span class="hljs-keyword">public</span> parentForm: FormGroup;\n\n    <span class="hljs-meta">@Input</span>(<span class="hljs-string">\'children\'</span>)\n    <span class="hljs-keyword">public</span> children: ChildData[];\n\n    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> cd: ChangeDetectorRef</span>) { }\n\n    ngOnInit() {\n        <span class="hljs-keyword">this</span>.parentForm.addControl(<span class="hljs-string">\'children\'</span>, <span class="hljs-keyword">new</span> FormArray([]));\n    }\n}</code></pre>\n<p>Huh.  That&#39;s too simple, right?  I mean, what exactly does this do if it&#39;s literally this small?  In the simplest case, this list component is strictly in charge of managing an array of children.  It does not, at the moment, care what a <code>ChildData</code> object looks like, it just knows that it&#39;s an array, and therefore it initializes an empty <code>FormArray</code> and attaches it to the parent form.  That&#39;s a pretty key detail there though - remember the goal of the parent being <em>&quot;acutely aware of the validity of the entire form&quot;</em>?  By attaching a new <code>FormArray</code>  control directly to the parent form, we&#39;ll get direct access in the parent controller to a data structure like the following:</p>\n<pre><code class="hljs typescript">parentForm.value = {\n    parentField1: <span class="hljs-built_in">string</span>;\n    parentField2: <span class="hljs-built_in">string</span>;\n    children: []\n}</code></pre>\n<p>And that&#39;s without the parent component <code>FormGroup</code> doing anything with <code>children</code> or <code>FormArray</code>&#39;s.  Cool, that seems like a nice separation of concerns.</p>\n<p>So, now we look at the template for the <code>ChildListComponent</code>:</p>\n<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"parentForm"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">formArrayName</span>=<span class="hljs-string">"children"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let child of children"</span>&gt;</span>\n            <span class="hljs-tag">&lt;<span class="hljs-name">app-child-form</span>\n                [<span class="hljs-attr">children</span>]=<span class="hljs-string">"parentForm.controls.children"</span>\n                [<span class="hljs-attr">child</span>]=<span class="hljs-string">"child"</span>&gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-name">app-child-form</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<p>Again, that&#39;s super simple.  We&#39;re basically saying the following:</p>\n<ul>\n<li>I&#39;m working within the <code>parentForm</code></li>\n<li>I&#39;m working on the <code>children</code> array of that form</li>\n<li>For each of those children, instantiate an <code>&lt;app-child-form&gt;</code> component, into which I&#39;ll pass the <code>children: FormArray</code> and the <code>child: ChildData</code> objects into</li>\n</ul>\n<h3 id="child-form-component">Child Form Component</h3>\n<pre><code class="hljs typescript"><span class="hljs-comment">// child-form.component.ts</span>\n<span class="hljs-meta">@Component</span>({ ... })\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ChildFormComponent <span class="hljs-keyword">implements</span> OnInit {\n    <span class="hljs-meta">@Input</span>(<span class="hljs-string">\'children\'</span>)\n    <span class="hljs-keyword">public</span> children: FormArray;\n\n    <span class="hljs-meta">@Input</span>(<span class="hljs-string">\'child\'</span>)\n    <span class="hljs-keyword">public</span> child: ChildData;\n\n    <span class="hljs-keyword">public</span> childForm: FormGroup;\n\n    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> fb: FormBuilder</span>) {}\n\n    ngOnInit() {\n        <span class="hljs-keyword">this</span>.childForm = <span class="hljs-keyword">this</span>.toFormGroup(<span class="hljs-keyword">this</span>.child);\n        <span class="hljs-keyword">this</span>.children.push(<span class="hljs-keyword">this</span>.childForm);\n    }\n\n    <span class="hljs-keyword">private</span> toFormGroup(data: ChildData) {\n        <span class="hljs-keyword">const</span> formGroup = <span class="hljs-keyword">this</span>.fb.group({\n            id: [ data.id ],\n            childField1: [ data.childField1 || <span class="hljs-string">\'\'</span>, Validators.required ],\n            childField2: [ data.childField2 || <span class="hljs-string">\'\'</span>, Validators.required ],\n            childHiddenField1: [ data.childHiddenField1 ]\n        });\n\n        <span class="hljs-keyword">return</span> formGroup;\n    }\n}</code></pre>\n<p>Cool, now we&#39;re down to the nitty gritty of what a <code>ChildData</code> and it&#39;s associated form looks like.  Notice how this component has <em>no idea</em> of what a <code>ParentData</code> or <code>parentForm</code> object is?  That&#39;s good.  All this component should need to know how to do is (1) setup a <code>FormGroup</code> for it&#39;s <code>child</code> instance, and (2) attach that to the <code>children: FormArray</code> we got from the <code>ChildListComponent</code>.  This is again a key point.  Remember that the incoming <code>FormArray</code> has already been attached to the <code>parentForm</code> in the list component.  By attaching our childForm to the parent <code>FormArray</code>, we&#39;ve attached it to the <code>parentForm</code>, which we actually know nothing about.  But it provides the <code>parentForm</code> awareness into the global validity of the entire form, all the way down to the child level.</p>\n<p>And then, the final template:</p>\n<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- child-form.component.html --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"childForm"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"childField1"</span>&gt;</span>Child Field 1<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"childField1"</span> /&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"childField1"</span>&gt;</span>Child Field 2<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"childField2"</span> /&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<p>And that&#39;s it.  This child form template is, not surprisingly, setting up inputs for it&#39;s <code>FormControl</code>&#39;s within it&#39;s own <code>childForm: formGroup</code>.</p>\n<h3 id="summary">Summary</h3>\n<p>So the final architecture and delegated responsibilities is:</p>\n<ul>\n<li>A <code>ParentFormComponent</code> who knows only about root level <code>ParentData</code> fields and how to prompt for them in inputs, nothing about it&#39;s children&#39;s structures or forms</li>\n<li>A <code>ChildListComponent</code> who knows only about an array of children, and is responsible for managing the array, but not the contents or the associated forms</li>\n<li>A <code>ChildFormComponent</code> who knows only about it&#39;s own root level <code>ChildData</code> fields, and simply attaches it&#39;s own form to the incoming <code>FormArray</code></li>\n</ul>\n<p>For more advanced usages of this setup, including form submission, adding/removing children, autosaving, undo/redo, and resetting form state - check out <a href="/post/nested-reactive-forms-in-angular2-continued/" title="Nested Reactive Forms in Angular2, Continued">the follow up post</a>.  Thanks for reading!</p>\n',excerpt:'Over at <a href="http://www.urbn.com" title="URBN">URBN</a>, I recently worked on a little internal app that involved a fairly complex nested form UI.  Having only done limited Angular2 work thus far, mostly using <a href="https://angular.io/docs/ts/latest/guide/upgrade.html" title="NgUpgrade">NgUpgrade</a> against an existing Angular1 app, it was a great learning experience in some of the new form capabilities offered in Angular2.  However, I couldn&apos;t find many great examples involving nested forms that felt clean/maintainable/etc.  After a few days of hacking, I was pretty happy with what we ended up with, and super excited about the new <a href="https://angular.io/docs/ts/latest/guide/reactive-forms.html" title="Reactive Forms">Reactive Forms</a> in Angular2.  ',permalink:"/post/nested-reactive-forms-in-angular2",readingTime:{text:"12 min read",minutes:11.03,time:661800,words:2206},slug:"nested-reactive-forms-in-angular2"},posts:[]},serverRendered:!0}}(void 0,"Matt Brophy")</script><script src="/_nuxt/runtime.e803325abfd56b48e81b.js" defer></script><script src="/_nuxt/async/pages/post/_slug.d851e136b06223941c64.js" defer></script><script src="/_nuxt/async/commons.app.818c68e7fc8bb0f5bf2d.js" defer></script><script src="/_nuxt/async/app.66828c9f8a8e67467d36.js" defer></script>
  </body>
</html>
